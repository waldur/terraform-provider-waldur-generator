{{- define "resource_extra_definitions" }}{{ end }}

{{- /* 
    resource_create_link handles the creation of a Link resource (e.g. Volume Attachment).
    A Link resource represents a relationship between two other resources (Source and Target).
    The 'Create' operation effectively creates this relationship in the API.
*/ -}}
{{- define "resource_create" }}
	var data {{ .Name | title }}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() { return }

	// Link Plugin Create Logic
	sourceUUID := data.{{ .Source.Param | title }}.ValueString()

	requestBody := {{ .Name | title }}CreateRequest{}
	requestBody.{{ .Target.Param | title }} = data.{{ .Target.Param | title }}.ValueStringPointer()
	requestBody.{{ .Source.Param | title }} = data.{{ .Source.Param | title }}.ValueStringPointer()
	{{- range .CreateFields }}
	{{- if and (ne .Name $.Source.Param) (ne .Name $.Target.Param) }}
	{{- if or (eq .Type "string") (eq .Type "integer") (eq .Type "boolean") (eq .Type "number") }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.IsUnknown() {
		{{- template "fieldAssignment" dict "Field" . "Target" "requestBody" }}
	}
	{{- end }}
	{{- end }}
	{{- end }}

	_, err := r.client.Link(ctx, &requestBody)
	if err != nil {
		resp.Diagnostics.AddError("Link Operation Failed", err.Error())
		return
	}
	
	// For Link resources, ID is composite of Source and Target UUIDs because the API might not return a distinct ID for the link itself.
	targetUUID := common.ExtractUUIDFromURL(data.{{ .Target.Param | title }}.ValueString())
	data.UUID = types.StringValue(sourceUUID + "/" + targetUUID)

	// Extract creation timeout
	timeout, diags := data.Timeouts.Create(ctx, common.DefaultCreateTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Fetch updated state and wait for it to be ready
	// The volume might be in "updating" state immediately after attach, so we wait for "OK".
	apiResp, err := common.WaitForResource(ctx, func(ctx context.Context) (*{{ .Name | title }}Response, error) {
		return r.client.Get(ctx, sourceUUID)
	}, timeout)
	if err != nil {
		resp.Diagnostics.AddError("Failed to wait for resource ready state after Link", err.Error())
		return
	}

	resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)
	
	// Restore composite ID overwritten by CopyFrom (which retrieves Source UUID)
	data.UUID = types.StringValue(sourceUUID + "/" + targetUUID)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
{{- end }}

{{- /* 
    resource_read verifies if the Link still exists.
    Since Links might not have a direct GET endpoint, we often read the Source resource
    and check if the Target resource (or the specific link object) is present in a specific field (e.g. 'volumes' list in an instance).
*/ -}}
{{- define "resource_read" }}
	// For Link resources, we read the Source resource and check if Target is linked
	parts := strings.Split(data.UUID.ValueString(), "/")
	if len(parts) != 2 {
		resp.Diagnostics.AddError("Invalid Link ID", "Expected source_uuid/target_uuid")
		return
	}
	sourceUUID := parts[0]
	targetUUID := parts[1]

	var result map[string]interface{}
	err := r.client.Client.Get(ctx, "{{ .APIPaths.Retrieve }}", sourceUUID, &result)
	if err != nil {
		if IsNotFoundError(err) {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Unable to Read Source Resource", err.Error())
		return
	}
	
	// Check if target is present in the source resource
	// The LinkCheckKey usually points to a list or a single object/string
	if val, ok := result["{{ .LinkCheckKey }}"]; ok {
		found := false
		if strVal, ok := val.(string); ok {
			// Single value link (e.g. 1-to-1)
			// Check if it matches targetUUID or is a URL containing targetUUID
			if strings.Contains(strVal, targetUUID) {
				found = true
			}
		} else if listVal, ok := val.([]interface{}); ok {
			// List of links (e.g. 1-to-many)
			for _, item := range listVal {
				if itemMap, ok := item.(map[string]interface{}); ok {
					if uuid, ok := itemMap["uuid"].(string); ok && uuid == targetUUID {
						found = true
						break
					}
					if url, ok := itemMap["url"].(string); ok && strings.Contains(url, targetUUID) {
						found = true
						break
					}
				}
			}
		}
		
		if !found {
			// Link not found, remove from state
			resp.State.RemoveResource(ctx)
			return
		}
	} else {
		// Key not present
		resp.State.RemoveResource(ctx)
		return
	}
	
	// We delete "uuid" from result before mapping to avoid overwriting the composite ID in data.UUID
	delete(result, "uuid") 
{{- end }}

{{- define "resource_update" }}
	// Link resources typically do not support update, as they are bindings.
	resp.Diagnostics.AddError("Update Not Supported", "Link resources cannot be updated.")
{{- end }}

{{- /* 
    resource_delete handles the removal of the relationship (Unlink).
*/ -}}
{{- define "resource_delete" }}
	var data {{ .Name | title }}ResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() { return }

	// Link Plugin Delete (Unlink)
	parts := strings.Split(data.UUID.ValueString(), "/")
	if len(parts) != 2 {
		resp.Diagnostics.AddError("Invalid Link ID", "Expected source_uuid/target_uuid")
		return
	}
	sourceUUID := parts[0]
	
	err := r.client.Unlink(ctx, sourceUUID)
	if err != nil && !IsNotFoundError(err) {
		resp.Diagnostics.AddError("Unlink Failed", err.Error())
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, common.DefaultDeleteTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	err = common.WaitForDeletion(ctx, func(ctx context.Context) (*{{ .Name | title }}Response, error) {
		return r.client.Get(ctx, data.UUID.ValueString())
	}, deleteTimeout)
	if err != nil {
		resp.Diagnostics.AddError("Failed to wait for resource deletion", err.Error())
		return
	}
{{- end }}

{{- /* 
    resource_import allows importing an existing link using the composite ID source_uuid/target_uuid.
*/ -}}
{{- define "resource_import" }}
	// Import ID: source_uuid/target_uuid
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 {
		resp.Diagnostics.AddError("Invalid Import ID", "Expected format: <{{ .Source.Param }}_uuid>/<{{ .Target.Param }}_uuid>")
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("{{ .Source.Param }}"), parts[0])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("{{ .Target.Param }}"), parts[1])...)
{{- end }}
