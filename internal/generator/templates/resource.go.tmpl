package resources

import (
	"context"
    "strings"
    {{ if .IsOrder }}"fmt"
    "os"
    "time"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"{{ end }}

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"

	"github.com/waldur/terraform-waldur-provider/internal/client"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &{{ .Name | title }}Resource{}
var _ resource.ResourceWithImportState = &{{ .Name | title }}Resource{}

func New{{ .Name | title }}Resource() resource.Resource {
	return &{{ .Name | title }}Resource{}
}

// {{ .Name | title }}Resource defines the resource implementation.
type {{ .Name | title }}Resource struct {
	client *client.Client
}

// {{ .Name | title }}ResourceModel describes the resource data model.
type {{ .Name | title }}ResourceModel struct {
	UUID types.String `tfsdk:"id"`
	{{- range .ModelFields }}
	{{ .Name | title }} {{ .GoType }} `tfsdk:"{{ .TFSDKName }}"`
	{{- end }}
	Timeouts timeouts.Value `tfsdk:"timeouts"`
}

func (r *{{ .Name | title }}Resource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ .Name }}"
}

func (r *{{ .Name | title }}Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "{{ .Name | title }} resource",

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Resource UUID (used as Terraform ID)",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			{{- range .ModelFields }}
			"{{ .TFSDKName }}": {{ template "schemaAttribute" . }}
			{{- end }}
		},

		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Update: true,
				Delete: true,
			}),
		},
	}
}

func (r *{{ .Name | title }}Resource) convertTFValue(v attr.Value) interface{} {
	if v.IsNull() || v.IsUnknown() {
		return nil
	}
	switch val := v.(type) {
	case types.String:
		return val.ValueString()
	case types.Int64:
		return val.ValueInt64()
	case types.Bool:
		return val.ValueBool()
	case types.Float64:
		return val.ValueFloat64()
	case types.List:
		items := make([]interface{}, len(val.Elements()))
		for i, elem := range val.Elements() {
			items[i] = r.convertTFValue(elem)
		}
		return items
	case types.Object:
		obj := make(map[string]interface{})
		for k, attr := range val.Attributes() {
			if converted := r.convertTFValue(attr); converted != nil {
				obj[k] = converted
			}
		}
		return obj
	}
	return nil
}

func (r *{{ .Name | title }}Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			"Expected *client.Client, got something else. Please report this issue to the provider developers.",
		)
		return
	}

	r.client = client
}

func (r *{{ .Name | title }}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data {{ .Name | title }}ResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	{{- if .IsOrder }}
	// Phase 1: Payload Construction
	attributes := map[string]interface{}{}
	{{- range .CreateFields }}
	{{- if and (ne .Name "project") (ne .Name "offering") }}
	{{- if eq .Type "string" }}
	if !data.{{ .Name | title }}.IsNull() {
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
	}
	{{- else if eq .Type "integer" }}
	if !data.{{ .Name | title }}.IsNull() {
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueInt64()
	}
	{{- else if eq .Type "boolean" }}
	if !data.{{ .Name | title }}.IsNull() {
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
	}
	{{- else if eq .Type "number" }}
	if !data.{{ .Name | title }}.IsNull() {
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueFloat64()
	}
	{{- else if eq .Type "array" }}
	if !data.{{ .Name | title }}.IsNull() {
		items := make([]interface{}, 0)
		{{- if eq .ItemType "string" }}
		for _, elem := range data.{{ .Name | title }}.Elements() {
			if strVal, ok := elem.(types.String); ok {
				items = append(items, strVal.ValueString())
			}
		}
		{{- else if eq .ItemType "integer" }}
		for _, elem := range data.{{ .Name | title }}.Elements() {
			if intVal, ok := elem.(types.Int64); ok {
				items = append(items, intVal.ValueInt64())
			}
		}
		{{- else if eq .ItemType "object" }}
		for _, elem := range data.{{ .Name | title }}.Elements() {
			items = append(items, r.convertTFValue(elem))
		}
		{{- end }}
		attributes["{{ .Name }}"] = items
	}
	{{- end }}
	{{- end }}
	{{- end }}

	payload := map[string]interface{}{
		"project":    data.Project.ValueString(),
		"offering":   data.Offering.ValueString(), // Assuming offering is passed as URL or UUID handled by API
		"attributes": attributes,
	}

	// Phase 2: Submit Order
	var orderRes map[string]interface{}
	err := r.client.Post(ctx, "/api/marketplace-orders/", payload, &orderRes)
	if err != nil {
		resp.Diagnostics.AddError("Order Submission Failed", err.Error())
		return
	}
	
	orderUUID, ok := orderRes["uuid"].(string)
	if !ok {
		resp.Diagnostics.AddError("Invalid Response", "Order UUID not found")
		return
	}

	// Phase 3: Poll for Completion
	// Attempt to resolve UUID
	if uuid, ok := orderRes["resource_uuid"].(string); ok {
		data.UUID = types.StringValue(uuid)
	} else {
		data.UUID = types.StringValue(orderUUID)
	}

	// Attempt to fetch the resource to populate state
	{
		var mpUUID string
		if uuid, ok := orderRes["resource_uuid"].(string); ok {
			mpUUID = uuid
		} else if uuid, ok := orderRes["marketplace_resource_uuid"].(string); ok {
			mpUUID = uuid
		}
		
		if mpUUID != "" {
			var mpRes map[string]interface{}
			err = r.client.GetByUUID(ctx, "/api/marketplace-resources/{uuid}/", mpUUID, &mpRes)
			if err == nil {
				// Debug logging
				tflog.Warn(ctx, fmt.Sprintf("Fetched MP Resource: %+v", mpRes))
				if val, exists := mpRes["resource_uuid"]; exists {
					tflog.Warn(ctx, fmt.Sprintf("resource_uuid type: %T, value: %v", val, val))
				} else {
					tflog.Warn(ctx, "resource_uuid key missing in MP response")
				}

				// Plugin Resource UUID is available directly in resource_uuid field
				if pluginUUID, ok := mpRes["resource_uuid"].(string); ok {
					if pluginUUID != "" {
						data.UUID = types.StringValue(pluginUUID)
						
						// Fetch Plugin Resource
						var pluginRes map[string]interface{}
						retrievePath := strings.Replace("{{ .APIPaths.Retrieve }}", "{uuid}", pluginUUID, 1)
						tflog.Warn(ctx, "Attempting to fetch plugin resource at: " + retrievePath)
						err = r.client.GetByUUID(ctx, retrievePath, pluginUUID, &pluginRes)
						if err == nil {
							tflog.Warn(ctx, "Successfully fetched plugin resource")
							sourceMap := pluginRes
							{{- template "mapResponseFields" . }}
						} else {
							tflog.Warn(ctx, "Failed to fetch plugin resource: " + err.Error())
						}
					} else {
						tflog.Warn(ctx, "resource_uuid is empty string")
					}
				} else {
					tflog.Warn(ctx, "Failed to cast resource_uuid to string")
				}
			} else {
				tflog.Warn(ctx, "Failed to fetch MP resource: " + err.Error())
			}
		}
	}

	if os.Getenv("WALDUR_E2E_SKIP_WAIT") != "" {
		tflog.Warn(ctx, "Skipping wait for order completion due to WALDUR_E2E_SKIP_WAIT")
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
		return
	}

	stateConf := &retry.StateChangeConf{
		Pending: []string{"pending", "executing", "created"},
		Target:  []string{"done"},
		Refresh: func() (interface{}, string, error) {
			var res map[string]interface{}
			err := r.client.GetByUUID(ctx, "/api/marketplace-orders/{uuid}/", orderUUID, &res)
			if err != nil {
				return nil, "", err
			}
			
			state, _ := res["state"].(string)
			if state == "erred" || state == "rejected" {
				msg, _ := res["error_message"].(string)
				return res, "failed", fmt.Errorf("order failed: %s", msg)
			}
			return res, state, nil
		},
		Timeout: func() time.Duration {
			timeout, diags := data.Timeouts.Create(ctx, 45*time.Minute)
			resp.Diagnostics.Append(diags...)
			return timeout
		}(),
		Delay: 10 * time.Second,
		MinTimeout: 5 * time.Second,
	}

	rawResult, err := stateConf.WaitForStateContext(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Order Failed", err.Error())
		return
	}
	
	result := rawResult.(map[string]interface{})
	if resourceUUID, ok := result["marketplace_resource_uuid"].(string); ok {
		data.UUID = types.StringValue(resourceUUID)
	} else {
		resp.Diagnostics.AddError("Resource UUID Missing", "Order completed but marketplace_resource_uuid is missing")
		return
	}

	// Fetch final resource state
	var finalState map[string]interface{}
	err = r.client.GetByUUID(ctx, "{{ .APIPaths.Retrieve }}", data.UUID.ValueString(), &finalState)
	if err != nil {
		resp.Diagnostics.AddError("Failed to Read Resource", err.Error())
		return
	}
	sourceMap := finalState
	{{- else }}
	// Prepare request body
	requestBody := map[string]interface{}{
		{{- range .CreateFields }}
		{{- if eq .Type "string" }}
		"{{ .Name }}": data.{{ .Name | title }}.ValueString(),
		{{- else if eq .Type "integer" }}
		"{{ .Name }}": data.{{ .Name | title }}.ValueInt64(),
		{{- else if eq .Type "boolean" }}
		"{{ .Name }}": data.{{ .Name | title }}.ValueBool(),
		{{- else if eq .Type "number" }}
		"{{ .Name }}": data.{{ .Name |title }}.ValueFloat64(),
		{{- end }}
		{{- end }}
	}

	// Call Waldur API to create resource
	var result map[string]interface{}
	
	{{- if .CreateOperation }}
	// Custom create operation via parent resource
	createPath := "{{ .APIPaths.Create }}"
	{{- range $key, $value := .CreateOperation.PathParams }}
	createPath = strings.Replace(createPath, "{{"{"}}{{ $key }}{{"}"}}", data.{{ $value | title }}.ValueString(), 1)
	{{- end }}
	err := r.client.Post(ctx, createPath, requestBody, &result)
	{{- else }}
	err := r.client.Create(ctx, "{{ .APIPaths.Create }}", requestBody, &result)
	{{- end }}
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Create {{ .Name | title }}",
			"An error occurred while creating the {{ .Name }}: "+err.Error(),
		)
		return
	}

	{{- if .CompositeKeys }}
	// Build composite ID from key fields
	compositeID := ""
	{{- range $i, $key := .CompositeKeys }}
	{{- if $i }}
	compositeID += "/"
	{{- end }}
	if v, ok := result["{{ $key }}"].(string); ok {
		compositeID += v
	} else if v, ok := result["{{ $key }}_uuid"].(string); ok {
		compositeID += v
	}
	{{- end }}
	data.UUID = types.StringValue(compositeID)
	{{- else }}
	// Extract UUID from response
	if uuid, ok := result["uuid"].(string); ok {
		data.UUID = types.StringValue(uuid)
	}
	{{- end }}

	sourceMap := result
	{{- end }}
	{{- template "mapResponseFields" . }}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{ .Name | title }}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data {{ .Name | title }}ResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Call Waldur API to read resource
	var result map[string]interface{}
	retrievePath := strings.Replace("{{ .APIPaths.Retrieve }}", "{uuid}", data.UUID.ValueString(), 1)
	
	err := r.client.GetByUUID(ctx, retrievePath, data.UUID.ValueString(), &result)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Read {{ .Name | title }}",
			"An error occurred while reading the {{ .Name }}: "+err.Error(),
		)
		return
	}

	// Update UUID from response
	if uuid, ok := result["uuid"].(string); ok {
		data.UUID = types.StringValue(uuid)
	}

	sourceMap := result
{{- template "mapResponseFields" . }}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{ .Name | title }}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data {{ .Name | title }}ResourceModel
	var state {{ .Name | title }}ResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	
	// Read current state to get the UUID (which is computed and not in plan)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}
	
	// Use UUID from state
	data.UUID = state.UUID

	{{- if .IsOrder }}
	// Phase 1: Standard PATCH (Simple fields)
	patchPayload := map[string]interface{}{}
	{{- range .UpdateFields }}
	{{- $fieldName := .Name }}
	{{- $isAction := false }}
	{{- range $.UpdateActions }}
		{{- if eq .Param $fieldName }}{{ $isAction = true }}{{ end }}
	{{- end }}
	{{- if and (not $isAction) (not .ReadOnly) }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.Equal(state.{{ .Name | title }}) {
		{{- if eq .Type "string" }}
		patchPayload["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
		{{- else if eq .Type "integer" }}
		patchPayload["{{ .Name }}"] = data.{{ .Name | title }}.ValueInt64()
		{{- else if eq .Type "boolean" }}
		patchPayload["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
		{{- else if eq .Type "number" }}
		patchPayload["{{ .Name }}"] = data.{{ .Name | title }}.ValueFloat64()
		{{- end }}
	}
	{{- end }}
	{{- end }}

	if len(patchPayload) > 0 {
		var result map[string]interface{}
		err := r.client.Update(ctx, "{{ .APIPaths.Update }}", data.UUID.ValueString(), patchPayload, &result)
		if err != nil {
			resp.Diagnostics.AddError("Update Failed", err.Error())
			return
		}
	}

	// Phase 2: RPC Actions
	if os.Getenv("WALDUR_E2E_SKIP_WAIT") != "" {
		tflog.Warn(ctx, "Skipping wait for update order completion due to WALDUR_E2E_SKIP_WAIT")
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
		return
	}

	{{- range $action := .UpdateActions }}
	if !data.{{ $action.Param | title }}.Equal(state.{{ $action.Param | title }}) {
		{{- $field := index $.ModelFields 0 }}
		{{- range $.ModelFields }}
		{{- if eq .Name $action.Param }}
		{{- $field = . }}
		{{- end }}
		{{- end }}
		
		// Convert Terraform value to API payload
		{{- if eq $field.GoType "types.List" }}
		{{ template "tfListToGo" (dict "ItemType" $field.ItemType "FieldName" ($action.Param | title) "Suffix" ($action.Name | title)) }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": items{{ $action.Name | title }},
		}
		{{- else if eq $field.GoType "types.Object" }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": r.convertTFValue(data.{{ $action.Param | title }}),
		}
		{{- else if eq $field.GoType "types.String" }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": data.{{ $action.Param | title }}.ValueString(),
		}
		{{- else if eq $field.GoType "types.Int64" }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": data.{{ $action.Param | title }}.ValueInt64(),
		}
		{{- else if eq $field.GoType "types.Bool" }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": data.{{ $action.Param | title }}.ValueBool(),
		}
		{{- end }}
		
		{{- if $action.Path }}
		actionUrl{{ $action.Name | title }} := strings.Replace("{{ $action.Path }}", "{uuid}", data.UUID.ValueString(), 1)
		{{- else }}
		actionUrl{{ $action.Name | title }} := fmt.Sprintf("/api/{{ $.Operations.List | replace "_list" "" | replace "_" "-" }}/%s/{{ $action.Name }}/", data.UUID.ValueString())
		{{- end }}
		var actionResult{{ $action.Name | title }} map[string]interface{}
		if err := r.client.Post(ctx, actionUrl{{ $action.Name | title }}, actionPayload{{ $action.Name | title }}, &actionResult{{ $action.Name | title }}); err != nil {
			resp.Diagnostics.AddError("RPC Action Failed: {{ $action.Name }}", err.Error())
			return
		}
	}
	{{- end }}

	// Fetch updated state
	var result map[string]interface{}
	err := r.client.GetByUUID(ctx, "{{ .APIPaths.Retrieve }}", data.UUID.ValueString(), &result)
	if err != nil {
		resp.Diagnostics.AddError("Failed to Read Resource After Update", err.Error())
		return
	}
	sourceMap := result
	{{- else }}
	// Prepare request body
	requestBody := map[string]interface{}{
		{{- range .UpdateFields }}
		{{- if eq .Type "string" }}
		"{{ .Name }}": data.{{ .Name | title }}.ValueString(),
		{{- else if eq .Type "integer" }}
		"{{ .Name }}": data.{{ .Name | title }}.ValueInt64(),
		{{- else if eq .Type "boolean" }}
		"{{ .Name }}": data.{{ .Name | title }}.ValueBool(),
		{{- else if eq .Type "number" }}
		"{{ .Name }}": data.{{ .Name | title }}.ValueFloat64(),
		{{- end }}
		{{- end }}
	}

	// Call Waldur API to update resource
	var result map[string]interface{}
	
	err := r.client.Update(ctx, "{{ .APIPaths.Update }}", data.UUID.ValueString(), requestBody, &result)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Update {{ .Name | title }}",
			"An error occurred while updating the {{ .Name }}: "+err.Error(),
		)
		return
	}

	// Update UUID from response
	if uuid, ok := result["uuid"].(string); ok {
		data.UUID = types.StringValue(uuid)
	}

	sourceMap := result
	{{- end }}
	{{- template "mapResponseFields" . }}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{ .Name | title }}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data {{ .Name | title }}ResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	{{- if .IsOrder }}
	// Order-based Delete
	payload := map[string]interface{}{}
	{{- range .TerminationAttributes }}
	if !data.{{ .Name | title }}.IsNull() {
		{{- if eq .Type "boolean" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
		{{- else if eq .Type "string" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
		{{- end }}
	}
	{{- end }}

	url := fmt.Sprintf("/api/marketplace-resources/%s/terminate/", data.UUID.ValueString())
	var res map[string]interface{}
	err := r.client.Post(ctx, url, payload, &res)
	if err != nil {
		resp.Diagnostics.AddError("Termination Failed", err.Error())
		return
	}
	
	// Wait for deletion if order UUID is returned
	if orderUUID, ok := res["uuid"].(string); ok {
		stateConf := &retry.StateChangeConf{
			Pending: []string{"pending", "executing", "created"},
			Target:  []string{"done"},
			Refresh: func() (interface{}, string, error) {
				var res map[string]interface{}
				err := r.client.GetByUUID(ctx, "/api/marketplace-orders/{uuid}/", orderUUID, &res)
				if err != nil {
					return nil, "", err
				}
				state, _ := res["state"].(string)
				if state == "erred" || state == "rejected" {
					return res, "failed", fmt.Errorf("termination order failed")
				}
				return res, state, nil
			},
			Timeout: func() time.Duration {
				timeout, diags := data.Timeouts.Delete(ctx, 45*time.Minute)
				resp.Diagnostics.Append(diags...)
				return timeout
			}(),
			Delay: 10 * time.Second,
			MinTimeout: 5 * time.Second,
		}
		_, err := stateConf.WaitForStateContext(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Termination Order Failed", err.Error())
			return
		}
	}
	{{- else }}
	// Call Waldur API to delete resource
	err := r.client.DeleteByUUID(ctx, "{{ .APIPaths.Delete }}", data.UUID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Delete {{ .Name | title }}",
			"An error occurred while deleting the {{ .Name }}: "+err.Error(),
		)
		return
	}
	{{- end }}
}

func (r *{{ .Name | title }}Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	{{- if .CompositeKeys }}
	// Parse composite ID: key1/key2/...
	parts := strings.Split(req.ID, "/")
	if len(parts) != {{ len .CompositeKeys }} {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			"Expected format: {{ range $i, $key := .CompositeKeys }}{{ if $i }}/{{ end }}<{{ $key }}>{{ end }}",
		)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
	{{- range $i, $key := .CompositeKeys }}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("{{ $key }}"), parts[{{ $i }}])...)
	{{- end }}
	{{- else }}
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
	{{- end }}
}
