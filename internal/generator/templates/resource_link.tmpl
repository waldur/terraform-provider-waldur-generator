{{- /* 
    resource_create_link handles the creation of a Link resource (e.g. Volume Attachment).
    A Link resource represents a relationship between two other resources (Source and Target).
    The 'Create' operation effectively creates this relationship in the API.
*/ -}}
{{- define "resource_create_link" }}
	// Link Plugin Create Logic
	sourceUUID := data.{{ .Source.Param | title }}.ValueString()

	requestBody := {{ .Name | title }}CreateRequest{
		{{ .Target.Param | title }}: data.{{ .Target.Param | title }}.ValueStringPointer(),
		{{- range .CreateFields }}
		{{- if and (ne .Name $.Source.Param) (ne .Name $.Target.Param) }}
		{{- if eq .Type "string" }}
		{{ .Name | title }}: data.{{ .Name | title }}.ValueStringPointer(),
		{{- else if eq .Type "integer" }}
		{{ .Name | title }}: data.{{ .Name | title }}.ValueInt64Pointer(),
		{{- else if eq .Type "boolean" }}
		{{ .Name | title }}: data.{{ .Name | title }}.ValueBoolPointer(),
		{{- else if eq .Type "number" }}
		{{ .Name | title }}: data.{{ .Name | title }}.ValueFloat64Pointer(),
		{{- end }}
		{{- end }}
		{{- end }}
	}

	apiResp, err := r.client.Link{{ .Name | title }}(ctx, &requestBody)
	if err != nil {
		resp.Diagnostics.AddError("Link Operation Failed", err.Error())
		return
	}
	
	// For Link resources, ID is composite of Source and Target UUIDs because the API might not return a distinct ID for the link itself.
	data.UUID = types.StringValue(sourceUUID + "/" + data.{{ .Target.Param | title }}.ValueString())

	resp.Diagnostics.Append(r.mapResponseToModel(ctx, *apiResp, &data)...)
{{- end }}

{{- /* 
    resource_read_link verifies if the Link still exists.
    Since Links might not have a direct GET endpoint, we often read the Source resource
    and check if the Target resource (or the specific link object) is present in a specific field (e.g. 'volumes' list in an instance).
*/ -}}
{{- define "resource_read_link" }}
	// For Link resources, we read the Source resource and check if Target is linked
	parts := strings.Split(data.UUID.ValueString(), "/")
	if len(parts) != 2 {
		resp.Diagnostics.AddError("Invalid Link ID", "Expected source_uuid/target_uuid")
		return
	}
	sourceUUID := parts[0]
	targetUUID := parts[1]

	var result map[string]interface{}
	err := r.client.Client.GetByUUID(ctx, "{{ .APIPaths.Retrieve }}", sourceUUID, &result)
	if err != nil {
		if client.IsNotFoundError(err) {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Unable to Read Source Resource", err.Error())
		return
	}
	
	// Check if target is present in the source resource
	// The LinkCheckKey usually points to a list or a single object/string
	if val, ok := result["{{ .LinkCheckKey }}"]; ok {
		found := false
		if strVal, ok := val.(string); ok {
			// Single value link (e.g. 1-to-1)
			// Check if it matches targetUUID or is a URL containing targetUUID
			if strings.Contains(strVal, targetUUID) {
				found = true
			}
		} else if listVal, ok := val.([]interface{}); ok {
			// List of links (e.g. 1-to-many)
			for _, item := range listVal {
				if itemMap, ok := item.(map[string]interface{}); ok {
					if uuid, ok := itemMap["uuid"].(string); ok && uuid == targetUUID {
						found = true
						break
					}
					if url, ok := itemMap["url"].(string); ok && strings.Contains(url, targetUUID) {
						found = true
						break
					}
				}
			}
		}
		
		if !found {
			// Link not found, remove from state
			resp.State.RemoveResource(ctx)
			return
		}
	} else {
		// Key not present
		resp.State.RemoveResource(ctx)
		return
	}
	
	// We delete "uuid" from result before mapping to avoid overwriting the composite ID in data.UUID
	delete(result, "uuid") 
{{- end }}

{{- /* 
    resource_delete_link handles the removal of the relationship (Unlink).
*/ -}}
{{- define "resource_delete_link" }}
	// Link Plugin Delete (Unlink)
	parts := strings.Split(data.UUID.ValueString(), "/")
	if len(parts) != 2 {
		resp.Diagnostics.AddError("Invalid Link ID", "Expected source_uuid/target_uuid")
		return
	}
	sourceUUID := parts[0]
	
	err := r.client.Unlink{{ .Name | title }}(ctx, sourceUUID)
	if err != nil {
		resp.Diagnostics.AddError("Unlink Failed", err.Error())
		return
	}
{{- end }}

{{- /* 
    resource_import_link allows importing an existing link using the composite ID source_uuid/target_uuid.
*/ -}}
{{- define "resource_import_link" }}
	// Import ID: source_uuid/target_uuid
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 {
		resp.Diagnostics.AddError("Invalid Import ID", "Expected format: <{{ .Source.Param }}_uuid>/<{{ .Target.Param }}_uuid>")
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("{{ .Source.Param }}"), parts[0])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("{{ .Target.Param }}"), parts[1])...)
{{- end }}
