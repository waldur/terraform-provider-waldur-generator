{{- define "resource_create_order" }}
	// Phase 1: Payload Construction
	attributes := {{ .Name | title }}CreateAttributes{
		{{- range .CreateFields }}
		{{- if and (ne .Name "project") (ne .Name "offering") }}
		{{- if or (eq .Type "string") (eq .Type "integer") (eq .Type "boolean") (eq .Type "number") }}
		{{ .Name | title }}: data.{{ .Name | title }}.Value{{ if eq .Type "string" }}String{{ else if eq .Type "integer" }}Int64{{ else if eq .Type "boolean" }}Bool{{ else if eq .Type "number" }}Float64{{ end }}Pointer(),
		{{- end }}
		{{- end }}
		{{- end }}
	}

	{{- range .CreateFields }}
	{{- if and (ne .Name "project") (ne .Name "offering") }}
	{{- if eq .Type "array" }}
	PopulateSliceField(ctx, data.{{ .Name | title }}, &attributes.{{ .Name | title }})
	{{- else if eq .Type "object" }}
	{
		var obj {{ $.Name | title }}Create{{ .Name | title }}Request
		if diags := data.{{ .Name | title }}.As(ctx, &obj, basetypes.ObjectAsOptions{}); !diags.HasError() {
			attributes.{{ .Name | title }} = &obj
		}
	}
	{{- end }}
	{{- end }}
	{{- end }}

	payload := {{ .Name | title }}CreateRequest{
		Project:    data.Project.ValueStringPointer(),
		Offering:   data.Offering.ValueStringPointer(),
		Attributes: attributes,
	}

	// Phase 2: Submit Order
	var orderRes map[string]interface{}
	err := r.client.Post(ctx, "/api/marketplace-orders/", payload, &orderRes)
	if err != nil {
		resp.Diagnostics.AddError("Order Submission Failed", err.Error())
		return
	}
	
	orderUUID, ok := orderRes["uuid"].(string)
	if !ok {
		resp.Diagnostics.AddError("Invalid Response", "Order UUID not found")
		return
	}

	// Phase 3: Poll for Completion
	// Attempt to resolve UUID
	if uuid, ok := orderRes["resource_uuid"].(string); ok {
		data.UUID = types.StringValue(uuid)
	} else {
		data.UUID = types.StringValue(orderUUID)
	}

	// Attempt to fetch the resource to populate state
	{
		var mpUUID string
		if uuid, ok := orderRes["resource_uuid"].(string); ok {
			mpUUID = uuid
		} else if uuid, ok := orderRes["marketplace_resource_uuid"].(string); ok {
			mpUUID = uuid
		}
		
		if mpUUID != "" {
			var mpRes map[string]interface{}
			err = r.client.GetByUUID(ctx, "/api/marketplace-resources/{uuid}/", mpUUID, &mpRes)
			if err == nil {
				// Debug logging
				tflog.Warn(ctx, fmt.Sprintf("Fetched MP Resource: %+v", mpRes))
				if val, exists := mpRes["resource_uuid"]; exists {
					tflog.Warn(ctx, fmt.Sprintf("resource_uuid type: %T, value: %v", val, val))
				} else {
					tflog.Warn(ctx, "resource_uuid key missing in MP response")
				}

				// Plugin Resource UUID is available directly in resource_uuid field
				if pluginUUID, ok := mpRes["resource_uuid"].(string); ok {
					if pluginUUID != "" {
						data.UUID = types.StringValue(pluginUUID)
						
						// Fetch Plugin Resource
						var apiResp {{ .Name | title }}ApiResponse
						retrievePath := strings.Replace("{{ .APIPaths.Retrieve }}", "{uuid}", pluginUUID, 1)
						tflog.Warn(ctx, "Attempting to fetch plugin resource at: " + retrievePath)
						err = r.client.GetByUUID(ctx, retrievePath, pluginUUID, &apiResp)
						if err == nil {
							tflog.Warn(ctx, "Successfully fetched plugin resource")
							resp.Diagnostics.Append(r.mapResponseToModel(ctx, apiResp, &data)...)
						} else {
							tflog.Warn(ctx, "Failed to fetch plugin resource: " + err.Error())
						}
					} else {
						tflog.Warn(ctx, "resource_uuid is empty string")
					}
				} else {
					tflog.Warn(ctx, "Failed to cast resource_uuid to string")
				}
			} else {
				tflog.Warn(ctx, "Failed to fetch MP resource: " + err.Error())
			}
		}
	}

	if os.Getenv("WALDUR_E2E_SKIP_WAIT") != "" {
		tflog.Warn(ctx, "Skipping wait for order completion due to WALDUR_E2E_SKIP_WAIT")
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
		return
	}

	stateConf := &retry.StateChangeConf{
		Pending: []string{"pending", "executing", "created"},
		Target:  []string{"done"},
		Refresh: func() (interface{}, string, error) {
			var res map[string]interface{}
			err := r.client.GetByUUID(ctx, "/api/marketplace-orders/{uuid}/", orderUUID, &res)
			if err != nil {
				return nil, "", err
			}
			
			state, _ := res["state"].(string)
			if state == "erred" || state == "rejected" {
				msg, _ := res["error_message"].(string)
				return res, "failed", fmt.Errorf("order failed: %s", msg)
			}
			return res, state, nil
		},
		Timeout: func() time.Duration {
			timeout, diags := data.Timeouts.Create(ctx, 45*time.Minute)
			resp.Diagnostics.Append(diags...)
			return timeout
		}(),
		Delay: 10 * time.Second,
		MinTimeout: 5 * time.Second,
	}

	rawResult, err := stateConf.WaitForStateContext(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Order Failed", err.Error())
		return
	}
	
	result := rawResult.(map[string]interface{})
	if resourceUUID, ok := result["marketplace_resource_uuid"].(string); ok {
		data.UUID = types.StringValue(resourceUUID)
	} else {
		resp.Diagnostics.AddError("Resource UUID Missing", "Order completed but marketplace_resource_uuid is missing")
		return
	}

	// Fetch final resource state
	var apiResp {{ .Name | title }}ApiResponse
	err = r.client.GetByUUID(ctx, "{{ .APIPaths.Retrieve }}", data.UUID.ValueString(), &apiResp)
	if err != nil {
		resp.Diagnostics.AddError("Failed to Read Resource", err.Error())
		return
	}
	resp.Diagnostics.Append(r.mapResponseToModel(ctx, apiResp, &data)...)
{{- end }}

{{- define "resource_update_order" }}
	// Phase 1: Standard PATCH (Simple fields)
	var patchPayload {{ .Name | title }}UpdateRequest
	{{- range .UpdateFields }}
	{{- $fieldName := .Name }}
	{{- $isAction := false }}
	{{- range $.UpdateActions }}
		{{- if eq .Param $fieldName }}{{ $isAction = true }}{{ end }}
	{{- end }}
	{{- if and (not $isAction) (not .ReadOnly) }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.Equal(state.{{ .Name | title }}) {
		{{- if eq .Type "string" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueStringPointer()
		{{- else if eq .Type "integer" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueInt64Pointer()
		{{- else if eq .Type "boolean" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueBoolPointer()
		{{- else if eq .Type "number" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueFloat64Pointer()
		{{- end }}
	}
	{{- end }}
	{{- end }}

	{
		var result map[string]interface{}
		err := r.client.Update(ctx, "{{ .APIPaths.Update }}", data.UUID.ValueString(), patchPayload, &result)
		if err != nil {
			resp.Diagnostics.AddError("Update Failed", err.Error())
			return
		}
		_ = result
	}

	// Phase 2: RPC Actions
	if os.Getenv("WALDUR_E2E_SKIP_WAIT") != "" {
		tflog.Warn(ctx, "Skipping wait for update order completion due to WALDUR_E2E_SKIP_WAIT")
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
		return
	}

	{{- range $action := .UpdateActions }}
	if !data.{{ $action.Param | title }}.Equal(state.{{ $action.Param | title }}) {
		{{- $field := index $.ModelFields 0 }}
		{{- range $.ModelFields }}
		{{- if eq .Name $action.Param }}
		{{- $field = . }}
		{{- end }}
		{{- end }}
		
		// Convert Terraform value to API payload
		var req {{ $.Name | title }}{{ $action.Name | title }}ActionRequest
		{{- if eq $field.GoType "types.List" }}
		PopulateSliceField(ctx, data.{{ $action.Param | title }}, &req.{{ $action.Param | title }})
		{{- else if eq $field.GoType "types.Object" }}
		var objVal {{ $.Name | title }}Create{{ $action.Param | title }}Request
		data.{{ $action.Param | title }}.As(ctx, &objVal, basetypes.ObjectAsOptions{})
		req.{{ $action.Param | title }} = &objVal
		{{- else if eq $field.GoType "types.String" }}
		req.{{ $action.Param | title }} = data.{{ $action.Param | title }}.ValueStringPointer()
		{{- else if eq $field.GoType "types.Int64" }}
		req.{{ $action.Param | title }} = data.{{ $action.Param | title }}.ValueInt64Pointer()
		{{- else if eq $field.GoType "types.Bool" }}
		req.{{ $action.Param | title }} = data.{{ $action.Param | title }}.ValueBoolPointer()
		{{- end }}
		
		{{- if $action.Path }}
		actionUrl{{ $action.Name | title }} := strings.Replace("{{ $action.Path }}", "{uuid}", data.UUID.ValueString(), 1)
		{{- else }}
		actionUrl{{ $action.Name | title }} := fmt.Sprintf("/api/{{ $.Operations.List | replace "_list" "" | replace "_" "-" }}/%s/{{ $action.Name }}/", data.UUID.ValueString())
		{{- end }}
		var actionResult{{ $action.Name | title }} map[string]interface{}
		if err := r.client.Post(ctx, actionUrl{{ $action.Name | title }}, req, &actionResult{{ $action.Name | title }}); err != nil {
			resp.Diagnostics.AddError("RPC Action Failed: {{ $action.Name }}", err.Error())
			return
		}
	}
	{{- end }}

	// Fetch updated state
	// Call Waldur API to read resource
	var apiResp {{ .Name | title }}ApiResponse

	retrievePath := strings.Replace("{{ .APIPaths.Retrieve }}", "{uuid}", data.UUID.ValueString(), 1)

	err := r.client.GetByUUID(ctx, retrievePath, data.UUID.ValueString(), &apiResp)
	if err != nil {
		if client.IsNotFoundError(err) {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Failed to Read Resource After Update", err.Error())
		return
	}
	resp.Diagnostics.Append(r.mapResponseToModel(ctx, apiResp, &data)...)
{{- end }}

{{- define "resource_delete_order" }}
	// Order-based Delete
	payload := map[string]interface{}{}
	{{- range .TerminationAttributes }}
	if !data.{{ .Name | title }}.IsNull() {
		{{- if eq .Type "boolean" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
		{{- else if eq .Type "string" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
		{{- end }}
	}
	{{- end }}

	url := fmt.Sprintf("/api/marketplace-resources/%s/terminate/", data.UUID.ValueString())
	var res map[string]interface{}
	err := r.client.Post(ctx, url, payload, &res)
	if err != nil {
		resp.Diagnostics.AddError("Termination Failed", err.Error())
		return
	}
	
	// Wait for deletion if order UUID is returned
	if orderUUID, ok := res["uuid"].(string); ok {
		stateConf := &retry.StateChangeConf{
			Pending: []string{"pending", "executing", "created"},
			Target:  []string{"done"},
			Refresh: func() (interface{}, string, error) {
				var res map[string]interface{}
				err := r.client.GetByUUID(ctx, "/api/marketplace-orders/{uuid}/", orderUUID, &res)
				if err != nil {
					return nil, "", err
				}
				state, _ := res["state"].(string)
				if state == "erred" || state == "rejected" {
					return res, "failed", fmt.Errorf("termination order failed")
				}
				return res, state, nil
			},
			Timeout: func() time.Duration {
				timeout, diags := data.Timeouts.Delete(ctx, 45*time.Minute)
				resp.Diagnostics.Append(diags...)
				return timeout
			}(),
			Delay: 10 * time.Second,
			MinTimeout: 5 * time.Second,
		}
		_, err := stateConf.WaitForStateContext(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Termination Order Failed", err.Error())
			return
		}
	}
{{- end }}
