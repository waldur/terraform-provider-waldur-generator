{{- /* 
    resource_create_order handles the creation workflow for OpenStack and other order-based resources.
    The workflow consists of 3 phases:
    1. Construct payload (Marketplace Order) with attributes.
    2. Submit the Order via the Marketplace API.
    3. Poll the Order status until it completes, then resolve the Resource UUID.
*/ -}}
{{- define "resource_create" }}
	var data {{ .Name | title }}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() { return }

	// Phase 1: Payload Construction
	// We map the Terraform schema fields to the 'attributes' map required by the Marketplace Order API.
	attributes := {{ .Name | title }}CreateAttributes{}
	{{- range .CreateFields }}
	{{- /* Skip project and offering as they are top-level order fields, not attributes */ -}}
	{{- if and (ne .Name "project") (ne .Name "offering") }}
	{{- if or (eq .Type "string") (eq .Type "integer") (eq .Type "boolean") (eq .Type "number") }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.IsUnknown() {
		{{- template "fieldAssignment" dict "Field" . "Target" "attributes" }}
	}
	{{- end }}
	{{- end }}
	{{- end }}

	{{- range .CreateFields }}
	{{- if and (ne .Name "project") (ne .Name "offering") }}
	{{- if eq .Type "array" }}
	{{- if .Required }}
	resp.Diagnostics.Append(common.{{ if eq .GoType "types.Set" }}PopulateSetField{{ else }}PopulateSliceField{{ end }}(ctx, data.{{ .Name | title }}, &attributes.{{ .Name | title }})...)
	{{- else }}
	resp.Diagnostics.Append(common.{{ if eq .GoType "types.Set" }}PopulateOptionalSetField{{ else }}PopulateOptionalSliceField{{ end }}(ctx, data.{{ .Name | title }}, &attributes.{{ .Name | title }})...)
	{{- end }}
	{{- else if eq .Type "object" }}
	{{- if .Required }}
	var obj {{ if .RefName }}common.{{ .RefName }}{{ else }}{{ $.Name | title }}Create{{ .Name | title }}Request{{ end }}
	diags := data.{{ .Name | title }}.As(ctx, &obj, basetypes.ObjectAsOptions{})
	resp.Diagnostics.Append(diags...)
	if !diags.HasError() {
		attributes.{{ .Name | title }} = obj
	}
	{{- else }}
	resp.Diagnostics.Append(common.PopulateOptionalObjectField(ctx, data.{{ .Name | title }}, &attributes.{{ .Name | title }})...)
	{{- end }}
	{{- end }}
	{{- end }}
	{{- end }}

	// Construct the Create Order Request
	payload := {{ .Name | title }}CreateRequest{
		Project:    data.Project.ValueStringPointer(),
		Offering:   data.Offering.ValueStringPointer(),
		Attributes: attributes,
	}

	if !data.Plan.IsNull() && !data.Plan.IsUnknown() {
		payload.Plan = data.Plan.ValueStringPointer()
	}

	if !data.Limits.IsNull() && !data.Limits.IsUnknown() {
		limits := make(map[string]float64)
		diags := data.Limits.ElementsAs(ctx, &limits, false)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		payload.Limits = limits
	}

	// Phase 2: Submit Order
	orderRes, err := r.client.CreateOrder(ctx, &payload)
	if err != nil {
		resp.Diagnostics.AddError("Order Submission Failed", err.Error())
		return
	}
	
	// Phase 3: Poll for Completion
	// We use the 'time' package to handle the timeout specified in the TF config or default to global default.
	timeout, diags := data.Timeouts.Create(ctx, common.DefaultCreateTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Wait for the order to reach a terminal state (done/erred)
	finalOrder, err := common.WaitForOrder(ctx, r.client.Client, *orderRes.Uuid, timeout)
	if err != nil {
		resp.Diagnostics.AddError("Order Failed", err.Error())
		return
	}
	
	// Resolve the created Resource UUID from the completed order
	if uuid := common.ResolveResourceUUID(finalOrder); uuid != "" {
		data.UUID = types.StringValue(uuid)
	} else {
		resp.Diagnostics.AddError("Resource UUID Missing", "Order completed but resource UUID is missing")
		return
	}

	// Fetch final resource state to ensure Terraform state matches reality
	apiResp, err := r.client.Get(ctx, data.UUID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Failed to Read Resource", err.Error())
		return
	}
	resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)

	// Resolve unknown attributes to explicit null values
	r.resolveUnknownAttributes(&data)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
{{- end }}

{{- /* 
    resource_update handles updates for order-based resources.
    Updates can be:
    1. Standard PATCH updates (e.g. name, description) which are simple API calls.
    2. RPC Actions (e.g. resize, update_security_groups) which trigger specific endpoints.
*/ -}}
{{- define "resource_update" }}
	var data {{ .Name | title }}ResourceModel
	var state {{ .Name | title }}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() { return }

	// Phase 1: Standard PATCH (Simple fields)
	// We compare the plan (data) with the state (state) to determine which fields changed.
	anyChanges := false
	var patchPayload {{ .Name | title }}UpdateRequest
	{{- range .UpdateFields }}
	{{- $fieldName := .Name }}
	{{- $isAction := false }}
	{{- range $.UpdateActions }}
		{{- if eq .Param $fieldName }}{{ $isAction = true }}{{ end }}
	{{- end }}
	{{- if and (not $isAction) (not .ReadOnly) }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.Equal(state.{{ .Name | title }}) {
		anyChanges = true
		{{- template "fieldAssignment" dict "Field" . "Target" "patchPayload" }}
	}
	{{- end }}
	{{- end }}

	if anyChanges {
		// Execute the PATCH request
		_, err := r.client.Update(ctx, data.UUID.ValueString(), &patchPayload)
		if err != nil {
			resp.Diagnostics.AddError("Update Failed", err.Error())
			return
		}
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, common.DefaultUpdateTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Phase 2: RPC Actions
	// These actions are triggered when their corresponding specific fields change.
	{{- range $action := .UpdateActions }}
	if !data.{{ $action.Param | title }}.Equal(state.{{ $action.Param | title }}) {
		// Convert Terraform value to API payload for the specific action
		var req {{ $.Name | title }}{{ $action.Name | title }}ActionRequest
		{{- $field := index $.ModelFields 0 }}
		{{- range $.ModelFields }}
		{{- if eq .Name $action.Param }}
		{{- $field = . }}
		{{- end }}
		{{- end }}

		{{- if eq $field.GoType "types.List" }}
		resp.Diagnostics.Append(common.PopulateSliceField(ctx, data.{{ $action.Param | title }}, &req.{{ $action.Param | title }})...)
		{{- else if eq $field.GoType "types.Set" }}
		resp.Diagnostics.Append(common.PopulateSetField(ctx, data.{{ $action.Param | title }}, &req.{{ $action.Param | title }})...)
		{{- else if eq $field.GoType "types.Object" }}
		var objVal {{ if $field.RefName }}common.{{ $field.RefName }}{{ else }}{{ $.Name | title }}Create{{ $action.Param | title }}Request{{ end }}
		resp.Diagnostics.Append(data.{{ $action.Param | title }}.As(ctx, &objVal, basetypes.ObjectAsOptions{})...)
		req.{{ $action.Param | title }} = &objVal
		{{- else }}
		{{- template "fieldAssignment" dict "Field" $field "Target" "req" }}
		{{- end }}

		// Execute the Action
		if err := r.client.{{ $action.Name | title }}(ctx, data.UUID.ValueString(), &req); err != nil {
			resp.Diagnostics.AddError("RPC Action Failed: {{ $action.Name }}", err.Error())
			return
		}

		// Wait for the resource to return to OK state
		apiResp, err := common.WaitForResource(ctx, func(ctx context.Context) (*{{ $.Name | title }}Response, error) {
			return r.client.Get(ctx, data.UUID.ValueString())
		}, updateTimeout)
		if err != nil {
			resp.Diagnostics.AddError("Wait for RPC action failed", err.Error())
			return
		}
		resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)
		state = data // Update local state to avoid repeated action calls if multiple fields changed (though actions are usually 1-to-1)
	}
	{{- end }}

	// Fetch updated state after all changes
	apiResp, err := r.client.Get(ctx, data.UUID.ValueString())
	if err != nil {
		if IsNotFoundError(err) {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Failed to Read Resource After Update", err.Error())
		return
	}
	resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)

	// Resolve unknown attributes to explicit null values
	r.resolveUnknownAttributes(&data)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
{{- end }}

{{- /* 
    resource_delete_order handles the termination of order-based resources.
    This typically involves creating a termination order and waiting for it to complete.
*/ -}}
{{- define "resource_delete" }}
	var data {{ .Name | title }}ResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() { return }

	// Order-based Delete
	{{- if eq .Name "openstack_instance" }}
	// OpenStack instances must be stopped before they can be terminated.
	// We check the runtime_state and stop it if it's not already SHUTOFF.
	currData, err := r.client.Get(ctx, data.UUID.ValueString())
	if err == nil && currData.RuntimeState != nil && *currData.RuntimeState == "ACTIVE" {
		tflog.Info(ctx, "Stopping Openstack instance before deletion", map[string]interface{}{
			"uuid": data.UUID.ValueString(),
		})
		// We ignore the initial stop error; if it fails, Terminate might still fail with 409
		// which is better than failing early if Stop is temporarily unavailable.
		_ = r.client.Stop(ctx, data.UUID.ValueString())
		
		// Wait for the instance to reach a stable OK state after stop.
		// Waldur will move it to OK with RuntimeState=SHUTOFF.
		timeout, _ := data.Timeouts.Delete(ctx, common.DefaultDeleteTimeout)
		_, _ = common.WaitForResource(ctx, func(ctx context.Context) (*OpenstackInstanceResponse, error) {
			return r.client.Get(ctx, data.UUID.ValueString())
		}, timeout)
	}
	{{- end }}

	payload := map[string]interface{}{}
	{{- range .TerminationAttributes }}
	if !data.{{ .Name | title }}.IsNull() {
		{{- if eq .Type "boolean" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
		{{- else if eq .Type "string" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
		{{- end }}
	}
	{{- end }}

	// Submit termination order
	{{- $hasMarketplaceUUID := false }}
	{{- range .ModelFields }}
	{{- if eq .Name "marketplace_resource_uuid" }}{{ $hasMarketplaceUUID = true }}{{ end }}
	{{- end }}
	resourceID := data.UUID.ValueString()
	{{- if $hasMarketplaceUUID }}
	if !data.MarketplaceResourceUuid.IsNull() && !data.MarketplaceResourceUuid.IsUnknown() {
		resourceID = data.MarketplaceResourceUuid.ValueString()
	}
	{{- end }}
	orderUUID, err := r.client.Terminate(ctx, resourceID, payload)
	if err != nil {
		resp.Diagnostics.AddError("Termination Failed", err.Error())
		return
	}
	
	// Wait for deletion if order UUID is returned
	if orderUUID != "" {
		timeout, diags := data.Timeouts.Delete(ctx, common.DefaultDeleteTimeout)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}

		_, err := common.WaitForOrder(ctx, r.client.Client, orderUUID, timeout)
		if err != nil {
			resp.Diagnostics.AddError("Termination Order Failed", err.Error())
			return
		}
	}
{{- end }}

{{- define "resource_read" }}
	{{ template "resource_read_base" . }}
	if resp.Diagnostics.HasError() {
		return
	}

	// Resolve unknown attributes to explicit null values
	r.resolveUnknownAttributes(&data)
{{- end }}

{{- define "resource_import" }}
	{{ template "resource_import_base" . }}
{{- end }}

{{- /* 
    resolveUnknownAttributesHelper generates a helper function that ensures fields not returned 
    by the Waldur GET API are set to explicit null values instead of remaining "Unknown".
    This includes:
    - Plan and Limits (common to all order-based resources)
    - Termination attributes (from config)
    - Creation-only fields like volume sizes (from CreateFields)
*/ -}}
{{- define "resolveUnknownAttributesHelper" }}
// resolveUnknownAttributes ensures that fields not returned by the Waldur GET API
// are set to explicit null values instead of remaining "Unknown".
func (r *{{ .Name | title }}Resource) resolveUnknownAttributes(data *{{ .Name | title }}ResourceModel) {
	// Iterate over all model fields to handle Unknown values
	{{- range .ModelFields }}
	if data.{{ .Name | title }}.IsUnknown() {
		{{- if eq .GoType "types.String" }}
		{{- if eq .Format "date-time" }}
		data.{{ .Name | title }} = timetypes.NewRFC3339Null()
		{{- else }}
		data.{{ .Name | title }} = types.StringNull()
		{{- end }}
		{{- else if eq .GoType "types.Int64" }}
		data.{{ .Name | title }} = types.Int64Null()
		{{- else if eq .GoType "types.Bool" }}
		data.{{ .Name | title }} = types.BoolNull()
		{{- else if eq .GoType "types.Float64" }}
		data.{{ .Name | title }} = types.Float64Null()
		{{- else if eq .GoType "types.Map" }}
		data.{{ .Name | title }} = types.MapNull(types.{{ if eq .ItemType "integer" }}Int64Type{{ else if eq .ItemType "boolean" }}BoolType{{ else if eq .ItemType "number" }}Float64Type{{ else }}StringType{{ end }})
		{{- else if eq .GoType "types.List" }}
		{{- if eq .ItemType "object" }}
		data.{{ .Name | title }} = types.ListNull({{ toAttrType .ItemSchema }})
		{{- else }}
		data.{{ .Name | title }} = types.ListNull(types.{{ if eq .ItemType "integer" }}Int64Type{{ else if eq .ItemType "boolean" }}BoolType{{ else if eq .ItemType "number" }}Float64Type{{ else }}StringType{{ end }})
		{{- end }}
		{{- else if eq .GoType "types.Set" }}
		{{- if eq .ItemType "object" }}
		data.{{ .Name | title }} = types.SetNull({{ toAttrType .ItemSchema }})
		{{- else }}
		data.{{ .Name | title }} = types.SetNull(types.{{ if eq .ItemType "integer" }}Int64Type{{ else if eq .ItemType "boolean" }}BoolType{{ else if eq .ItemType "number" }}Float64Type{{ else }}StringType{{ end }})
		{{- end }}
		{{- else if eq .GoType "types.Object" }}
		data.{{ .Name | title }} = types.ObjectNull({{ toAttrType . }}.AttrTypes)
		{{- end }}
	}
	{{- end }}
}
{{- end }}

