{{- /* 
    resource_create_order handles the creation workflow for OpenStack and other order-based resources.
    The workflow consists of 3 phases:
    1. Construct payload (Marketplace Order) with attributes.
    2. Submit the Order via the Marketplace API.
    3. Poll the Order status until it completes, then resolve the Resource UUID.
*/ -}}
{{- define "resource_create_order" }}
	// Phase 1: Payload Construction
	// We map the Terraform schema fields to the 'attributes' map required by the Marketplace Order API.
	attributes := {{ .Name | title }}CreateAttributes{
		{{- range .CreateFields }}
		{{- /* Skip project and offering as they are top-level order fields, not attributes */ -}}
		{{- if and (ne .Name "project") (ne .Name "offering") }}
		{{- if or (eq .Type "string") (eq .Type "integer") (eq .Type "boolean") (eq .Type "number") }}
		{{ .Name | title }}: data.{{ .Name | title }}.Value{{ if eq .Type "string" }}String{{ else if eq .Type "integer" }}Int64{{ else if eq .Type "boolean" }}Bool{{ else if eq .Type "number" }}Float64{{ end }}Pointer(),
		{{- end }}
		{{- end }}
		{{- end }}
	}

	{{- range .CreateFields }}
	{{- if and (ne .Name "project") (ne .Name "offering") }}
	{{- if eq .Type "array" }}
	{
		{{- if eq .ItemType "string" }}
		var items []string
		diags := data.{{ .Name | title }}.ElementsAs(ctx, &items, false)
		resp.Diagnostics.Append(diags...)
		if !diags.HasError() {
			{{- if .Required }}
			if len(items) > 0 {
				attributes.{{ .Name | title }} = items
			}
			{{- else }}
			if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.IsUnknown() {
				attributes.{{ .Name | title }} = &items
			}
			{{- end }}
		}
		{{- else if eq .ItemType "integer" }}
		var items []int64
		diags := data.{{ .Name | title }}.ElementsAs(ctx, &items, false)
		resp.Diagnostics.Append(diags...)
		if !diags.HasError() {
			{{- if .Required }}
			if len(items) > 0 {
				attributes.{{ .Name | title }} = items
			}
			{{- else }}
			if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.IsUnknown() {
				attributes.{{ .Name | title }} = &items
			}
			{{- end }}
		}
		{{- else }}
		var items []{{ if .ItemSchema.RefName }}common.{{ .ItemSchema.RefName }}{{ else }}{{ $.Name | title }}Create{{ .Name | title }}Request{{ end }}
		diags := data.{{ .Name | title }}.ElementsAs(ctx, &items, false)
		resp.Diagnostics.Append(diags...)
		if !diags.HasError() {
			{{- if .Required }}
			if len(items) > 0 {
				attributes.{{ .Name | title }} = items
			}
			{{- else }}
			if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.IsUnknown() {
				attributes.{{ .Name | title }} = &items
			}
			{{- end }}
		}
		{{- end }}
	}
	{{- else if eq .Type "object" }}
	{
		var obj {{ if .RefName }}common.{{ .RefName }}{{ else }}{{ $.Name | title }}Create{{ .Name | title }}Request{{ end }}
		if diags := data.{{ .Name | title }}.As(ctx, &obj, basetypes.ObjectAsOptions{}); !diags.HasError() {
			attributes.{{ .Name | title }} = &obj
		}
	}
	{{- end }}
	{{- end }}
	{{- end }}

	// Construct the Create Order Request
	payload := {{ .Name | title }}CreateRequest{
		Project:    data.Project.ValueStringPointer(),
		Offering:   data.Offering.ValueStringPointer(),
		Attributes: attributes,
	}

	// Phase 2: Submit Order
	orderRes, err := r.client.Create{{ .Name | title }}Order(ctx, &payload)
	if err != nil {
		resp.Diagnostics.AddError("Order Submission Failed", err.Error())
		return
	}
	
	// Phase 3: Poll for Completion
	// We use the 'time' package to handle the timeout specified in the TF config or default to global default.
	timeout, diags := data.Timeouts.Create(ctx, common.DefaultCreateTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Wait for the order to reach a terminal state (done/erred)
	finalOrder, err := common.WaitForOrder(ctx, r.client.Client, *orderRes.Uuid, timeout)
	if err != nil {
		resp.Diagnostics.AddError("Order Failed", err.Error())
		return
	}
	
	// Resolve the created Resource UUID from the completed order
	if uuid := common.ResolveResourceUUID(finalOrder); uuid != "" {
		data.UUID = types.StringValue(uuid)
	} else {
		resp.Diagnostics.AddError("Resource UUID Missing", "Order completed but resource UUID is missing")
		return
	}

	// Fetch final resource state to ensure Terraform state matches reality
	apiResp, err := r.client.Get{{ .Name | title }}(ctx, data.UUID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Failed to Read Resource", err.Error())
		return
	}
	resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)
{{- end }}

{{- /* 
    resource_update_order handles updates for order-based resources.
    Updates can be:
    1. Standard PATCH updates (e.g. name, description) which are simple API calls.
    2. RPC Actions (e.g. resize, update_security_groups) which trigger specific endpoints.
*/ -}}
{{- define "resource_update_order" }}
	// Phase 1: Standard PATCH (Simple fields)
	// We compare the plan (data) with the state (state) to determine which fields changed.
	var patchPayload {{ .Name | title }}UpdateRequest
	{{- range .UpdateFields }}
	{{- $fieldName := .Name }}
	{{- $isAction := false }}
	{{- range $.UpdateActions }}
		{{- if eq .Param $fieldName }}{{ $isAction = true }}{{ end }}
	{{- end }}
	{{- if and (not $isAction) (not .ReadOnly) }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.Equal(state.{{ .Name | title }}) {
		{{- if eq .Type "string" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueStringPointer()
		{{- else if eq .Type "integer" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueInt64Pointer()
		{{- else if eq .Type "boolean" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueBoolPointer()
		{{- else if eq .Type "number" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueFloat64Pointer()
		{{- end }}
	}
	{{- end }}
	{{- end }}

	{
		// Execute the PATCH request
		_, err := r.client.Update{{ .Name | title }}(ctx, data.UUID.ValueString(), &patchPayload)
		if err != nil {
			resp.Diagnostics.AddError("Update Failed", err.Error())
			return
		}
	}

	// Phase 2: RPC Actions
	// These actions are triggered when their corresponding specific fields change.
	{{- range $action := .UpdateActions }}
	if !data.{{ $action.Param | title }}.Equal(state.{{ $action.Param | title }}) {
		// Convert Terraform value to API payload for the specific action
		var req {{ $.Name | title }}{{ $action.Name | title }}ActionRequest
		{{- $field := index $.ModelFields 0 }}
		{{- range $.ModelFields }}
		{{- if eq .Name $action.Param }}
		{{- $field = . }}
		{{- end }}
		{{- end }}

		{{- if eq $field.GoType "types.List" }}
		common.PopulateSliceField(ctx, data.{{ $action.Param | title }}, &req.{{ $action.Param | title }})
		{{- else if eq $field.GoType "types.Set" }}
		common.PopulateSetField(ctx, data.{{ $action.Param | title }}, &req.{{ $action.Param | title }})
		{{- else if eq $field.GoType "types.Object" }}
		var objVal {{ if $field.RefName }}common.{{ $field.RefName }}{{ else }}{{ $.Name | title }}Create{{ $action.Param | title }}Request{{ end }}
		data.{{ $action.Param | title }}.As(ctx, &objVal, basetypes.ObjectAsOptions{})
		req.{{ $action.Param | title }} = &objVal
		{{- else if eq $field.GoType "types.String" }}
		req.{{ $action.Param | title }} = data.{{ $action.Param | title }}.ValueStringPointer()
		{{- else if eq $field.GoType "types.Int64" }}
		req.{{ $action.Param | title }} = data.{{ $action.Param | title }}.ValueInt64Pointer()
		{{- else if eq $field.GoType "types.Bool" }}
		req.{{ $action.Param | title }} = data.{{ $action.Param | title }}.ValueBoolPointer()
		{{- end }}

		// Execute the Action
		if err := r.client.{{ $.Name | title }}{{ $action.Name | title }}(ctx, data.UUID.ValueString(), &req); err != nil {
			resp.Diagnostics.AddError("RPC Action Failed: {{ $action.Name }}", err.Error())
			return
		}
	}
	{{- end }}

	// Fetch updated state after all changes
	apiResp, err := r.client.Get{{ .Name | title }}(ctx, data.UUID.ValueString())
	if err != nil {
		if IsNotFoundError(err) {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Failed to Read Resource After Update", err.Error())
		return
	}
	resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)
{{- end }}

{{- /* 
    resource_delete_order handles the termination of order-based resources.
    This typically involves creating a termination order and waiting for it to complete.
*/ -}}
{{- define "resource_delete_order" }}
	// Order-based Delete
	payload := map[string]interface{}{}
	{{- range .TerminationAttributes }}
	if !data.{{ .Name | title }}.IsNull() {
		{{- if eq .Type "boolean" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
		{{- else if eq .Type "string" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
		{{- end }}
	}
	{{- end }}

	// Submit termination order
	orderUUID, err := r.client.Terminate{{ .Name | title }}(ctx, data.UUID.ValueString(), payload)
	if err != nil {
		resp.Diagnostics.AddError("Termination Failed", err.Error())
		return
	}
	
	// Wait for deletion if order UUID is returned
	if orderUUID != "" {
		timeout, diags := data.Timeouts.Delete(ctx, common.DefaultDeleteTimeout)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}

		_, err := common.WaitForOrder(ctx, r.client.Client, orderUUID, timeout)
		if err != nil {
			resp.Diagnostics.AddError("Termination Order Failed", err.Error())
			return
		}
	}
{{- end }}
