{{- define "resource_create_order" }}
	// Phase 1: Payload Construction
	attributes := sdk.{{ .Name | title }}CreateAttributes{
		{{- range .CreateFields }}
		{{- if and (ne .Name "project") (ne .Name "offering") }}
		{{- if or (eq .Type "string") (eq .Type "integer") (eq .Type "boolean") (eq .Type "number") }}
		{{ .Name | title }}: data.{{ .Name | title }}.Value{{ if eq .Type "string" }}String{{ else if eq .Type "integer" }}Int64{{ else if eq .Type "boolean" }}Bool{{ else if eq .Type "number" }}Float64{{ end }}Pointer(),
		{{- end }}
		{{- end }}
		{{- end }}
	}

	{{- range .CreateFields }}
	{{- if and (ne .Name "project") (ne .Name "offering") }}
	{{- if eq .Type "array" }}
	PopulateSliceField(ctx, data.{{ .Name | title }}, &attributes.{{ .Name | title }})
	{{- else if eq .Type "object" }}
	{
		var obj {{ if .RefName }}sdk.{{ .RefName }}{{ else }}sdk.{{ $.Name | title }}Create{{ .Name | title }}Request{{ end }}
		if diags := data.{{ .Name | title }}.As(ctx, &obj, basetypes.ObjectAsOptions{}); !diags.HasError() {
			attributes.{{ .Name | title }} = &obj
		}
	}
	{{- end }}
	{{- end }}
	{{- end }}

	payload := sdk.{{ .Name | title }}CreateRequest{
		Project:    data.Project.ValueStringPointer(),
		Offering:   data.Offering.ValueStringPointer(),
		Attributes: attributes,
	}

	// Phase 2: Submit Order
	orderRes, err := r.client.Create{{ .Name | title }}Order(ctx, &payload)
	if err != nil {
		resp.Diagnostics.AddError("Order Submission Failed", err.Error())
		return
	}
	
	if orderRes.UUID == nil {
		resp.Diagnostics.AddError("Invalid Response", "Order UUID not found")
		return
	}
	orderUUID := *orderRes.UUID

	// Phase 3: Poll for Completion
	// Attempt to resolve UUID
	if orderRes.ResourceUuid != nil {
		data.UUID = types.StringPointerValue(orderRes.ResourceUuid)
	} else if orderRes.MarketplaceResourceUuid != nil {
		data.UUID = types.StringPointerValue(orderRes.MarketplaceResourceUuid)
	} else {
		data.UUID = types.StringValue(orderUUID)
	}

	// Attempt to fetch the resource to populate state
	{
		var mpUUID string
		if orderRes.ResourceUuid != nil {
			mpUUID = *orderRes.ResourceUuid
		} else if orderRes.MarketplaceResourceUuid != nil { 
			mpUUID = *orderRes.MarketplaceResourceUuid
		}
		
		if mpUUID != "" {
			var mpRes map[string]interface{}
			err = r.client.GetByUUID(ctx, "/api/marketplace-resources/{uuid}/", mpUUID, &mpRes)
			if err == nil {
				// Plugin Resource UUID
				if pluginUUID, ok := mpRes["resource_uuid"].(string); ok && pluginUUID != "" {
					data.UUID = types.StringValue(pluginUUID)
					
					// Fetch Plugin Resource Typed
					apiResp, err := r.client.Get{{ .Name | title }}(ctx, pluginUUID)
					if err == nil {
						resp.Diagnostics.Append(r.mapResponseToModel(ctx, *apiResp, &data)...)
					}
				}
			}
		}
	}

	stateConf := &retry.StateChangeConf{
		Pending: []string{"pending", "executing", "created"},
		Target:  []string{"done"},
		Refresh: func() (interface{}, string, error) {
			// Poll Order
			var resMap map[string]interface{}
			err := r.client.GetByUUID(ctx, "/api/marketplace-orders/{uuid}/", orderUUID, &resMap)
			if err != nil {
				return nil, "", err
			}
			
			state, _ := resMap["state"].(string)
			if state == "erred" || state == "rejected" {
				msg, _ := resMap["error_message"].(string)
				return resMap, "failed", fmt.Errorf("order failed: %s", msg)
			}
			return resMap, state, nil
		},
		Timeout: func() time.Duration {
			timeout, diags := data.Timeouts.Create(ctx, 45*time.Minute)
			resp.Diagnostics.Append(diags...)
			return timeout
		}(),
		Delay: 10 * time.Second,
		MinTimeout: 5 * time.Second,
	}

	rawResult, err := stateConf.WaitForStateContext(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Order Failed", err.Error())
		return
	}
	
	result := rawResult.(map[string]interface{})
	if resourceUUID, ok := result["marketplace_resource_uuid"].(string); ok {
		data.UUID = types.StringValue(resourceUUID)
	} else {
		resp.Diagnostics.AddError("Resource UUID Missing", "Order completed but marketplace_resource_uuid is missing")
		return
	}

	// Fetch final resource state
	apiResp, err := r.client.Get{{ .Name | title }}(ctx, data.UUID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Failed to Read Resource", err.Error())
		return
	}
	resp.Diagnostics.Append(r.mapResponseToModel(ctx, *apiResp, &data)...)
{{- end }}

{{- define "resource_update_order" }}
	// Phase 1: Standard PATCH (Simple fields)
	var patchPayload sdk.{{ .Name | title }}UpdateRequest
	{{- range .UpdateFields }}
	{{- $fieldName := .Name }}
	{{- $isAction := false }}
	{{- range $.UpdateActions }}
		{{- if eq .Param $fieldName }}{{ $isAction = true }}{{ end }}
	{{- end }}
	{{- if and (not $isAction) (not .ReadOnly) }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.Equal(state.{{ .Name | title }}) {
		{{- if eq .Type "string" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueStringPointer()
		{{- else if eq .Type "integer" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueInt64Pointer()
		{{- else if eq .Type "boolean" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueBoolPointer()
		{{- else if eq .Type "number" }}
		patchPayload.{{ .Name | title }} = data.{{ .Name | title }}.ValueFloat64Pointer()
		{{- end }}
	}
	{{- end }}
	{{- end }}

	{
		_, err := r.client.Update{{ .Name | title }}(ctx, data.UUID.ValueString(), &patchPayload)
		if err != nil {
			resp.Diagnostics.AddError("Update Failed", err.Error())
			return
		}
	}

	// Phase 2: RPC Actions
	{{- range $action := .UpdateActions }}
	if !data.{{ $action.Param | title }}.Equal(state.{{ $action.Param | title }}) {
		// Convert Terraform value to API payload
		var req sdk.{{ $.Name | title }}{{ $action.Name | title }}ActionRequest
		{{- $field := index $.ModelFields 0 }}
		{{- range $.ModelFields }}
		{{- if eq .Name $action.Param }}
		{{- $field = . }}
		{{- end }}
		{{- end }}

		{{- if eq $field.GoType "types.List" }}
		PopulateSliceField(ctx, data.{{ $action.Param | title }}, &req.{{ $action.Param | title }})
		{{- else if eq $field.GoType "types.Object" }}
		var objVal {{ if $field.RefName }}sdk.{{ $field.RefName }}{{ else }}sdk.{{ $.Name | title }}Create{{ $action.Param | title }}Request{{ end }}
		data.{{ $action.Param | title }}.As(ctx, &objVal, basetypes.ObjectAsOptions{})
		req.{{ $action.Param | title }} = &objVal
		{{- else if eq $field.GoType "types.String" }}
		req.{{ $action.Param | title }} = data.{{ $action.Param | title }}.ValueStringPointer()
		{{- else if eq $field.GoType "types.Int64" }}
		req.{{ $action.Param | title }} = data.{{ $action.Param | title }}.ValueInt64Pointer()
		{{- else if eq $field.GoType "types.Bool" }}
		req.{{ $action.Param | title }} = data.{{ $action.Param | title }}.ValueBoolPointer()
		{{- end }}

		if err := r.client.{{ $.Name | title }}{{ $action.Name | title }}(ctx, data.UUID.ValueString(), &req); err != nil {
			resp.Diagnostics.AddError("RPC Action Failed: {{ $action.Name }}", err.Error())
			return
		}
	}
	{{- end }}

	// Fetch updated state
	apiResp, err := r.client.Get{{ .Name | title }}(ctx, data.UUID.ValueString())
	if err != nil {
		if client.IsNotFoundError(err) {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Failed to Read Resource After Update", err.Error())
		return
	}
	resp.Diagnostics.Append(r.mapResponseToModel(ctx, *apiResp, &data)...)
{{- end }}

{{- define "resource_delete_order" }}
	// Order-based Delete
	payload := map[string]interface{}{}
	{{- range .TerminationAttributes }}
	if !data.{{ .Name | title }}.IsNull() {
		{{- if eq .Type "boolean" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
		{{- else if eq .Type "string" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
		{{- end }}
	}
	{{- end }}

	orderUUID, err := r.client.Terminate{{ .Name | title }}(ctx, data.UUID.ValueString(), payload)
	if err != nil {
		resp.Diagnostics.AddError("Termination Failed", err.Error())
		return
	}
	
	// Wait for deletion if order UUID is returned
	if orderUUID != "" {
		stateConf := &retry.StateChangeConf{
			Pending: []string{"pending", "executing", "created"},
			Target:  []string{"done"},
			Refresh: func() (interface{}, string, error) {
				var res map[string]interface{}
				// Use Untyped GetByUUID for order usage as fallback
				err := r.client.GetByUUID(ctx, "/api/marketplace-orders/{uuid}/", orderUUID, &res)
				if err != nil {
					return nil, "", err
				}
				state, _ := res["state"].(string)
				if state == "erred" || state == "rejected" {
					return res, "failed", fmt.Errorf("termination order failed")
				}
				return res, state, nil
			},
			Timeout: func() time.Duration {
				timeout, diags := data.Timeouts.Delete(ctx, 45*time.Minute)
				resp.Diagnostics.Append(diags...)
				return timeout
			}(),
			Delay: 10 * time.Second,
			MinTimeout: 5 * time.Second,
		}
		_, err := stateConf.WaitForStateContext(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Termination Order Failed", err.Error())
			return
		}
	}
{{- end }}
