{{- define "resource_create_order" }}
	// Phase 1: Payload Construction
	attributes := map[string]interface{}{}
	{{- range .CreateFields }}
	{{- if and (ne .Name "project") (ne .Name "offering") }}
	{{- if .Required }}
		{{- if eq .Type "string" }}
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
		{{- else if eq .Type "integer" }}
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueInt64()
		{{- else if eq .Type "boolean" }}
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
		{{- else if eq .Type "number" }}
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueFloat64()
		{{- else if eq .Type "array" }}
		items := make([]interface{}, 0)
		{{- if eq .ItemType "string" }}
		for _, elem := range data.{{ .Name | title }}.Elements() {
			if strVal, ok := elem.(types.String); ok {
				items = append(items, strVal.ValueString())
			}
		}
		{{- else if eq .ItemType "integer" }}
		for _, elem := range data.{{ .Name | title }}.Elements() {
			if intVal, ok := elem.(types.Int64); ok {
				items = append(items, intVal.ValueInt64())
			}
		}
		{{- else if eq .ItemType "object" }}
		for _, elem := range data.{{ .Name | title }}.Elements() {
			items = append(items, ConvertTFValue(elem))
		}
		{{- end }}
		attributes["{{ .Name }}"] = items
		{{- end }}
	{{- else }}
	{{- if eq .Type "string" }}
	if !data.{{ .Name | title }}.IsNull() {
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
	}
	{{- else if eq .Type "integer" }}
	if !data.{{ .Name | title }}.IsNull() {
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueInt64()
	}
	{{- else if eq .Type "boolean" }}
	if !data.{{ .Name | title }}.IsNull() {
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
	}
	{{- else if eq .Type "number" }}
	if !data.{{ .Name | title }}.IsNull() {
		attributes["{{ .Name }}"] = data.{{ .Name | title }}.ValueFloat64()
	}
	{{- else if eq .Type "array" }}
	if !data.{{ .Name | title }}.IsNull() {
		items := make([]interface{}, 0)
		{{- if eq .ItemType "string" }}
		for _, elem := range data.{{ .Name | title }}.Elements() {
			if strVal, ok := elem.(types.String); ok {
				items = append(items, strVal.ValueString())
			}
		}
		{{- else if eq .ItemType "integer" }}
		for _, elem := range data.{{ .Name | title }}.Elements() {
			if intVal, ok := elem.(types.Int64); ok {
				items = append(items, intVal.ValueInt64())
			}
		}
		{{- else if eq .ItemType "object" }}
		for _, elem := range data.{{ .Name | title }}.Elements() {
			items = append(items, ConvertTFValue(elem))
		}
		{{- end }}
		attributes["{{ .Name }}"] = items
	}
	{{- end }}
	{{- end }}
	{{- end }}
	{{- end }}

	payload := map[string]interface{}{
		"project":    data.Project.ValueString(),
		"offering":   data.Offering.ValueString(),
		"attributes": attributes,
	}

	// Phase 2: Submit Order
	var orderRes map[string]interface{}
	err := r.client.Post(ctx, "/api/marketplace-orders/", payload, &orderRes)
	if err != nil {
		resp.Diagnostics.AddError("Order Submission Failed", err.Error())
		return
	}
	
	orderUUID, ok := orderRes["uuid"].(string)
	if !ok {
		resp.Diagnostics.AddError("Invalid Response", "Order UUID not found")
		return
	}

	// Phase 3: Poll for Completion
	// Attempt to resolve UUID
	if uuid, ok := orderRes["resource_uuid"].(string); ok {
		data.UUID = types.StringValue(uuid)
	} else {
		data.UUID = types.StringValue(orderUUID)
	}

	// Attempt to fetch the resource to populate state
	{
		var mpUUID string
		if uuid, ok := orderRes["resource_uuid"].(string); ok {
			mpUUID = uuid
		} else if uuid, ok := orderRes["marketplace_resource_uuid"].(string); ok {
			mpUUID = uuid
		}
		
		if mpUUID != "" {
			var mpRes map[string]interface{}
			err = r.client.GetByUUID(ctx, "/api/marketplace-resources/{uuid}/", mpUUID, &mpRes)
			if err == nil {
				// Debug logging
				tflog.Warn(ctx, fmt.Sprintf("Fetched MP Resource: %+v", mpRes))
				if val, exists := mpRes["resource_uuid"]; exists {
					tflog.Warn(ctx, fmt.Sprintf("resource_uuid type: %T, value: %v", val, val))
				} else {
					tflog.Warn(ctx, "resource_uuid key missing in MP response")
				}

				// Plugin Resource UUID is available directly in resource_uuid field
				if pluginUUID, ok := mpRes["resource_uuid"].(string); ok {
					if pluginUUID != "" {
						data.UUID = types.StringValue(pluginUUID)
						
						// Fetch Plugin Resource
						var pluginRes map[string]interface{}
						retrievePath := strings.Replace("{{ .APIPaths.Retrieve }}", "{uuid}", pluginUUID, 1)
						tflog.Warn(ctx, "Attempting to fetch plugin resource at: " + retrievePath)
						err = r.client.GetByUUID(ctx, retrievePath, pluginUUID, &pluginRes)
						if err == nil {
							tflog.Warn(ctx, "Successfully fetched plugin resource")
							sourceMap := pluginRes
							{{- template "mapResponseFields" . }}
						} else {
							tflog.Warn(ctx, "Failed to fetch plugin resource: " + err.Error())
						}
					} else {
						tflog.Warn(ctx, "resource_uuid is empty string")
					}
				} else {
					tflog.Warn(ctx, "Failed to cast resource_uuid to string")
				}
			} else {
				tflog.Warn(ctx, "Failed to fetch MP resource: " + err.Error())
			}
		}
	}

	if os.Getenv("WALDUR_E2E_SKIP_WAIT") != "" {
		tflog.Warn(ctx, "Skipping wait for order completion due to WALDUR_E2E_SKIP_WAIT")
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
		return
	}

	stateConf := &retry.StateChangeConf{
		Pending: []string{"pending", "executing", "created"},
		Target:  []string{"done"},
		Refresh: func() (interface{}, string, error) {
			var res map[string]interface{}
			err := r.client.GetByUUID(ctx, "/api/marketplace-orders/{uuid}/", orderUUID, &res)
			if err != nil {
				return nil, "", err
			}
			
			state, _ := res["state"].(string)
			if state == "erred" || state == "rejected" {
				msg, _ := res["error_message"].(string)
				return res, "failed", fmt.Errorf("order failed: %s", msg)
			}
			return res, state, nil
		},
		Timeout: func() time.Duration {
			timeout, diags := data.Timeouts.Create(ctx, 45*time.Minute)
			resp.Diagnostics.Append(diags...)
			return timeout
		}(),
		Delay: 10 * time.Second,
		MinTimeout: 5 * time.Second,
	}

	rawResult, err := stateConf.WaitForStateContext(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Order Failed", err.Error())
		return
	}
	
	result := rawResult.(map[string]interface{})
	if resourceUUID, ok := result["marketplace_resource_uuid"].(string); ok {
		data.UUID = types.StringValue(resourceUUID)
	} else {
		resp.Diagnostics.AddError("Resource UUID Missing", "Order completed but marketplace_resource_uuid is missing")
		return
	}

	// Fetch final resource state
	var finalState map[string]interface{}
	err = r.client.GetByUUID(ctx, "{{ .APIPaths.Retrieve }}", data.UUID.ValueString(), &finalState)
	if err != nil {
		resp.Diagnostics.AddError("Failed to Read Resource", err.Error())
		return
	}
	sourceMap := finalState
	{{- template "mapResponseFields" . }}
{{- end }}

{{- define "resource_update_order" }}
	// Phase 1: Standard PATCH (Simple fields)
	patchPayload := map[string]interface{}{}
	{{- range .UpdateFields }}
	{{- $fieldName := .Name }}
	{{- $isAction := false }}
	{{- range $.UpdateActions }}
		{{- if eq .Param $fieldName }}{{ $isAction = true }}{{ end }}
	{{- end }}
	{{- if and (not $isAction) (not .ReadOnly) }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.Equal(state.{{ .Name | title }}) {
		{{- if eq .Type "string" }}
		patchPayload["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
		{{- else if eq .Type "integer" }}
		patchPayload["{{ .Name }}"] = data.{{ .Name | title }}.ValueInt64()
		{{- else if eq .Type "boolean" }}
		patchPayload["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
		{{- else if eq .Type "number" }}
		patchPayload["{{ .Name }}"] = data.{{ .Name | title }}.ValueFloat64()
		{{- end }}
	}
	{{- end }}
	{{- end }}

	if len(patchPayload) > 0 {
		var result map[string]interface{}
		err := r.client.Update(ctx, "{{ .APIPaths.Update }}", data.UUID.ValueString(), patchPayload, &result)
		if err != nil {
			resp.Diagnostics.AddError("Update Failed", err.Error())
			return
		}
	}

	// Phase 2: RPC Actions
	if os.Getenv("WALDUR_E2E_SKIP_WAIT") != "" {
		tflog.Warn(ctx, "Skipping wait for update order completion due to WALDUR_E2E_SKIP_WAIT")
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
		return
	}

	{{- range $action := .UpdateActions }}
	if !data.{{ $action.Param | title }}.Equal(state.{{ $action.Param | title }}) {
		{{- $field := index $.ModelFields 0 }}
		{{- range $.ModelFields }}
		{{- if eq .Name $action.Param }}
		{{- $field = . }}
		{{- end }}
		{{- end }}
		
		// Convert Terraform value to API payload
		{{- if eq $field.GoType "types.List" }}
		{{ template "tfListToGo" (dict "ItemType" $field.ItemType "FieldName" ($action.Param | title) "Suffix" ($action.Name | title)) }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": items{{ $action.Name | title }},
		}
		{{- else if eq $field.GoType "types.Object" }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": ConvertTFValue(data.{{ $action.Param | title }}),
		}
		{{- else if eq $field.GoType "types.String" }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": data.{{ $action.Param | title }}.ValueString(),
		}
		{{- else if eq $field.GoType "types.Int64" }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": data.{{ $action.Param | title }}.ValueInt64(),
		}
		{{- else if eq $field.GoType "types.Bool" }}
		actionPayload{{ $action.Name | title }} := map[string]interface{}{
			"{{ $action.Param }}": data.{{ $action.Param | title }}.ValueBool(),
		}
		{{- end }}
		
		{{- if $action.Path }}
		actionUrl{{ $action.Name | title }} := strings.Replace("{{ $action.Path }}", "{uuid}", data.UUID.ValueString(), 1)
		{{- else }}
		actionUrl{{ $action.Name | title }} := fmt.Sprintf("/api/{{ $.Operations.List | replace "_list" "" | replace "_" "-" }}/%s/{{ $action.Name }}/", data.UUID.ValueString())
		{{- end }}
		var actionResult{{ $action.Name | title }} map[string]interface{}
		if err := r.client.Post(ctx, actionUrl{{ $action.Name | title }}, actionPayload{{ $action.Name | title }}, &actionResult{{ $action.Name | title }}); err != nil {
			resp.Diagnostics.AddError("RPC Action Failed: {{ $action.Name }}", err.Error())
			return
		}
	}
	{{- end }}

	// Fetch updated state
	// Call Waldur API to read resource
	var result map[string]interface{}

	retrievePath := strings.Replace("{{ .APIPaths.Retrieve }}", "{uuid}", data.UUID.ValueString(), 1)

	err := r.client.GetByUUID(ctx, retrievePath, data.UUID.ValueString(), &result)
	if err != nil {
		resp.Diagnostics.AddError("Failed to Read Resource After Update", err.Error())
		return
	}
	sourceMap := result
	{{- template "mapResponseFields" . }}
{{- end }}

{{- define "resource_delete_order" }}
	// Order-based Delete
	payload := map[string]interface{}{}
	{{- range .TerminationAttributes }}
	if !data.{{ .Name | title }}.IsNull() {
		{{- if eq .Type "boolean" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueBool()
		{{- else if eq .Type "string" }}
		payload["{{ .Name }}"] = data.{{ .Name | title }}.ValueString()
		{{- end }}
	}
	{{- end }}

	url := fmt.Sprintf("/api/marketplace-resources/%s/terminate/", data.UUID.ValueString())
	var res map[string]interface{}
	err := r.client.Post(ctx, url, payload, &res)
	if err != nil {
		resp.Diagnostics.AddError("Termination Failed", err.Error())
		return
	}
	
	// Wait for deletion if order UUID is returned
	if orderUUID, ok := res["uuid"].(string); ok {
		stateConf := &retry.StateChangeConf{
			Pending: []string{"pending", "executing", "created"},
			Target:  []string{"done"},
			Refresh: func() (interface{}, string, error) {
				var res map[string]interface{}
				err := r.client.GetByUUID(ctx, "/api/marketplace-orders/{uuid}/", orderUUID, &res)
				if err != nil {
					return nil, "", err
				}
				state, _ := res["state"].(string)
				if state == "erred" || state == "rejected" {
					return res, "failed", fmt.Errorf("termination order failed")
				}
				return res, state, nil
			},
			Timeout: func() time.Duration {
				timeout, diags := data.Timeouts.Delete(ctx, 45*time.Minute)
				resp.Diagnostics.Append(diags...)
				return timeout
			}(),
			Delay: 10 * time.Second,
			MinTimeout: 5 * time.Second,
		}
		_, err := stateConf.WaitForStateContext(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Termination Order Failed", err.Error())
			return
		}
	}
{{- end }}
