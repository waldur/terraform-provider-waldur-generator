{{- /* Helper template for populating request body with a single field */ -}}
{{- define "populateRequestBodyField" -}}
{{- /* Expects: .Field (FieldInfo), .IsCreate (bool for Required field handling) */ -}}
{{- $field := .Field -}}
{{- $skipPathParam := .SkipPathParam -}}
{{- if $skipPathParam }}
{{- if not (isPathParam $.Operation $field.Name) }}
{{- template "fieldAssignment" $field }}
{{- end }}
{{- else }}
{{- template "fieldAssignment" $field }}
{{- end }}
{{- end -}}

{{- /* Helper template for field assignment based on type */ -}}
{{- define "fieldAssignment" -}}
{{- if .Required }}
	{{- if eq .Type "string" }}
	requestBody.{{ .Name | title }} = data.{{ .Name | title }}.ValueStringPointer()
	{{- else if eq .Type "integer" }}
	requestBody.{{ .Name | title }} = data.{{ .Name | title }}.ValueInt64Pointer()
	{{- else if eq .Type "boolean" }}
	requestBody.{{ .Name | title }} = data.{{ .Name | title }}.ValueBoolPointer()
	{{- else if eq .Type "number" }}
	requestBody.{{ .Name | title }} = data.{{ .Name | title }}.ValueFloat64Pointer()
	{{- else if eq .GoType "types.Map" }}
	{
		var mapItems map[string]interface{}
		if diags := data.{{ .Name | title }}.ElementsAs(ctx, &mapItems, false); !diags.HasError() && len(mapItems) > 0 {
			requestBody.{{ .Name | title }} = mapItems
		}
	}
	{{- else if eq .Type "array" }}
	{
		{{- if eq .ItemType "string" }}
		var items []string
		if diags := data.{{ .Name | title }}.ElementsAs(ctx, &items, false); !diags.HasError() && len(items) > 0 {
			requestBody.{{ .Name | title }} = items
		}
		{{- else if eq .ItemType "integer" }}
		var items []int64
		if diags := data.{{ .Name | title }}.ElementsAs(ctx, &items, false); !diags.HasError() && len(items) > 0 {
			requestBody.{{ .Name | title }} = items
		}
		{{- else }}
		// Object array or other
		var items []{{ if .ItemSchema.RefName }}{{ if hasSuffix .ItemSchema.RefName "Request" }}{{ .ItemSchema.RefName }}{{ else }}{{ .ItemSchema.RefName }}Request{{ end }}{{ else }}{{ $.Prefix }}{{ .Name | title }}Request{{ end }}
		if diags := data.{{ .Name | title }}.ElementsAs(ctx, &items, false); !diags.HasError() && len(items) > 0 {
			requestBody.{{ .Name | title }} = items
		}
		{{- end }}
	}
	{{- else if eq .Type "object" }}
	{
		var obj {{ if .RefName }}{{ if hasSuffix .RefName "Request" }}{{ .RefName }}{{ else }}{{ .RefName }}Request{{ end }}{{ else }}{{ $.Prefix }}{{ .Name | title }}Request{{ end }}
		if diags := data.{{ .Name | title }}.As(ctx, &obj, basetypes.ObjectAsOptions{}); !diags.HasError() {
			requestBody.{{ .Name | title }} = &obj
		}
	}
	{{- end }}
{{- else }}
	{{- /* Optional fields */ -}}
	{{- if eq .Type "string" }}
	requestBody.{{ .Name | title }} = data.{{ .Name | title }}.ValueStringPointer()
	{{- else if eq .Type "integer" }}
	requestBody.{{ .Name | title }} = data.{{ .Name | title }}.ValueInt64Pointer()
	{{- else if eq .Type "boolean" }}
	requestBody.{{ .Name | title }} = data.{{ .Name | title }}.ValueBoolPointer()
	{{- else if eq .Type "number" }}
	requestBody.{{ .Name | title }} = data.{{ .Name | title }}.ValueFloat64Pointer()
	{{- else if eq .GoType "types.Map" }}
		var mapItems map[string]interface{}
		if diags := data.{{ .Name | title }}.ElementsAs(ctx, &mapItems, false); !diags.HasError() && len(mapItems) > 0 {
			requestBody.{{ .Name | title }} = mapItems
		}
	{{- else if eq .Type "array" }}
    {
		{{- if eq .ItemType "string" }}
		var items []string
		if diags := data.{{ .Name | title }}.ElementsAs(ctx, &items, false); !diags.HasError() && len(items) > 0 {
			requestBody.{{ .Name | title }} = items
		}
		{{- else if eq .ItemType "integer" }}
		var items []int64
		if diags := data.{{ .Name | title }}.ElementsAs(ctx, &items, false); !diags.HasError() && len(items) > 0 {
			requestBody.{{ .Name | title }} = items
		}
		{{- else }}
		var items []{{ if .ItemSchema.RefName }}{{ if hasSuffix .ItemSchema.RefName "Request" }}{{ .ItemSchema.RefName }}{{ else }}{{ .ItemSchema.RefName }}Request{{ end }}{{ else }}{{ $.Prefix }}{{ .Name | title }}Request{{ end }}
		if diags := data.{{ .Name | title }}.ElementsAs(ctx, &items, false); !diags.HasError() && len(items) > 0 {
			requestBody.{{ .Name | title }} = items
		}
		{{- end }}
    }
	{{- else if eq .Type "object" }}
    {
		var obj {{ if .RefName }}{{ if hasSuffix .RefName "Request" }}{{ .RefName }}{{ else }}{{ .RefName }}Request{{ end }}{{ else }}{{ $.Prefix }}{{ .Name | title }}Request{{ end }}
		if diags := data.{{ .Name | title }}.As(ctx, &obj, basetypes.ObjectAsOptions{}); !diags.HasError() {
			requestBody.{{ .Name | title }} = &obj
		}
    }
	{{- end }}
{{- end }}
{{- end -}}

{{- /* Helper template for building request body from fields */ -}}
{{- define "buildRequestBody" -}}
{{- /* Expects: .Fields ([]FieldInfo), .Operation (for path param check, can be nil) */ -}}
	// Prepare request body
	// Prepare request body
{{- range .Fields }}
{{- if $.Operation }}
{{- if not (isPathParam $.Operation .Name) }}
{{- template "fieldAssignment" dict "Name" .Name "Type" .Type "GoType" .GoType "ItemType" .ItemType "Required" .Required "Prefix" $.Prefix "Operation" $.Operation "ItemSchema" .ItemSchema "RefName" .RefName }}
{{- end }}
{{- else }}
{{- template "fieldAssignment" dict "Name" .Name "Type" .Type "GoType" .GoType "ItemType" .ItemType "Required" .Required "Prefix" $.Prefix "Operation" nil "ItemSchema" .ItemSchema "RefName" .RefName }}
{{- end }}
{{- end }}
{{- end -}}

{{- define "resource_create_standard" }}

	{{- /* Check if there are any body fields (non-path-param fields) */ -}}
	{{- $hasBodyFields := false }}
	{{- range .CreateFields }}
	{{- if not (isPathParam $.CreateOperation .Name) }}
	{{- $hasBodyFields = true }}
	{{- end }}
	{{- end }}

	// Call Waldur API to create resource
	var apiResp {{ .Name | title }}ApiResponse
	
	{{- if .CreateOperation }}
	// Custom create operation via parent resource
	createPath := "{{ .APIPaths.Create }}"
	{{- range $key, $value := .CreateOperation.PathParams }}
	createPath = strings.Replace(createPath, "{{"{"}}{{ $key }}{{"}"}}", data.{{ $value | title }}.ValueString(), 1)
	{{- end }}
	{{- if $hasBodyFields }}
	var requestBody {{ .Name | title }}CreateRequest
	{{- template "buildRequestBody" dict "Fields" .CreateFields "Operation" .CreateOperation "Prefix" (printf "%sCreate" (.Name | title)) }}
	err := r.client.Post(ctx, createPath, requestBody, &apiResp)
	{{- else }}
	err := r.client.Post(ctx, createPath, nil, &apiResp)
	{{- end }}
	{{- else }}
	{{- if $hasBodyFields }}
	var requestBody {{ .Name | title }}CreateRequest
	{{- template "buildRequestBody" dict "Fields" .CreateFields "Operation" nil "Prefix" (printf "%sCreate" (.Name | title)) }}
	err := r.client.Create(ctx, "{{ .APIPaths.Create }}", requestBody, &apiResp)
	{{- else }}
	err := r.client.Create(ctx, "{{ .APIPaths.Create }}", nil, &apiResp)
	{{- end }}
	{{- end }}
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Create {{ .Name | humanize }}",
			"An error occurred while creating the {{ .Name | humanize }}: "+err.Error(),
		)
		return
	}

	{{- if .CompositeKeys }}
	// Build composite ID from key fields
	compositeID := ""
	{{- range $i, $key := .CompositeKeys }}
	{{- if $i }}
	compositeID += "/"
	{{- end }}
	if apiResp.{{ $key | title }} != nil {
		val := *apiResp.{{ $key | title }}
		if strings.Contains(val, "/") {
			parts := strings.Split(strings.TrimRight(val, "/"), "/")
			val = parts[len(parts)-1]
		}
		compositeID += val
	}
	{{- end }}
	data.UUID = types.StringValue(compositeID)
	{{- else }}
	// Extract UUID from response
	if apiResp.UUID != nil {
		data.UUID = types.StringPointerValue(apiResp.UUID)
	}
	{{- end }}

	resp.Diagnostics.Append(r.mapResponseToModel(ctx, apiResp, &data)...)

{{- end }}

{{- define "resource_read_standard" }}
	{{- if .CompositeKeys }}
	// If UUID is unknown or contains slashes (composite key), try to look it up using composite keys
	if data.UUID.IsNull() || data.UUID.IsUnknown() || strings.Contains(data.UUID.ValueString(), "/") {
		filters := map[string]string{}
		{{- range $key := .CompositeKeys }}
		if !data.{{ $key | title }}.IsNull() {
			if v := data.{{ $key | title }}.ValueString(); v != "" {
				filters["{{ $key }}"] = v
			}
		}
		{{- end }}

		expectedCount := 0
		{{- range .CompositeKeys }}
		expectedCount++
		{{- end }}

		if len(filters) == expectedCount {
			var listResult []map[string]interface{}
			// Construct list path from Retrieve path by removing {uuid}/
			listPath := strings.Replace("{{ .APIPaths.Retrieve }}", "{uuid}/", "", 1)
			
			err := r.client.ListWithFilter(ctx, listPath, filters, &listResult)
			if err != nil {
				resp.Diagnostics.AddError("Failed to lookup resource by composite keys", err.Error())
				return
			}
			
			if len(listResult) == 1 {
				if uuid, ok := listResult[0]["uuid"].(string); ok {
					data.UUID = types.StringValue(uuid)
				}
			} else if len(listResult) > 1 {
				resp.Diagnostics.AddError("Ambiguous resource", fmt.Sprintf("Found %d resources matching composite keys", len(listResult)))
				return
			} else {
				resp.Diagnostics.AddError("Resource not found", "No resource found matching composite keys")
				return
			}
		}
	}
	{{- end }}

	retrievePath := strings.Replace("{{ .APIPaths.Retrieve }}", "{uuid}", data.UUID.ValueString(), 1)
	
	var apiResp {{ .Name | title }}ApiResponse
	err := r.client.GetByUUID(ctx, retrievePath, data.UUID.ValueString(), &apiResp)
	if err != nil {
		if client.IsNotFoundError(err) {
			resp.State.RemoveResource(ctx)
			return
		}

		resp.Diagnostics.AddError(
			"Unable to Read {{ .Name | humanize }}",
			"An error occurred while reading the {{ .Name | humanize }}: "+err.Error(),
		)
		return
	}
	
	resp.Diagnostics.Append(r.mapResponseToModel(ctx, apiResp, &data)...)
{{- end }}

{{- define "resource_update_standard" }}
	var requestBody {{ .Name | title }}UpdateRequest
	{{- template "buildRequestBody" dict "Fields" .UpdateFields "Operation" nil "Prefix" (printf "%sUpdate" (.Name | title)) }}

	// Call Waldur API to update resource
	var apiResp {{ .Name | title }}ApiResponse
	
	err := r.client.Update(ctx, "{{ .APIPaths.Update }}", data.UUID.ValueString(), requestBody, &apiResp)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Update {{ .Name | humanize }}",
			"An error occurred while updating the {{ .Name | humanize }}: "+err.Error(),
		)
		return
	}

	// Update UUID from response
	if apiResp.UUID != nil {
		data.UUID = types.StringPointerValue(apiResp.UUID)
	}

	resp.Diagnostics.Append(r.mapResponseToModel(ctx, apiResp, &data)...)
{{- end }}

{{- define "resource_delete_standard" }}
	// Call Waldur API to delete resource
	err := r.client.DeleteByUUID(ctx, "{{ .APIPaths.Delete }}", data.UUID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Delete {{ .Name | humanize }}",
			"An error occurred while deleting the {{ .Name | humanize }}: "+err.Error(),
		)
		return
	}
{{- end }}

{{- define "resource_import_standard" }}
	{{- if .CompositeKeys }}
	// Parse composite ID: key1/key2/...
	parts := strings.Split(req.ID, "/")
	if len(parts) != {{ len .CompositeKeys }} {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			"Expected format: {{ range $i, $key := .CompositeKeys }}{{ if $i }}/{{ end }}<{{ $key }}>{{ end }}",
		)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
	{{- range $i, $key := .CompositeKeys }}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("{{ $key }}"), parts[{{ $i }}])...)
	{{- end }}
	{{- else }}
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
	{{- end }}
{{- end }}
