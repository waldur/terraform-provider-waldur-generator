

{{- /* Helper template for complex field assignment (Post-Init) */ -}}
{{- define "complexFieldAssignment" -}}
	{{- if eq .GoType "types.Map" }}
	{
		var mapItems map[string]interface{}
		diags := data.{{ .Name | title }}.ElementsAs(ctx, &mapItems, false)
		resp.Diagnostics.Append(diags...)
		if !diags.HasError() && len(mapItems) > 0 {
			requestBody.{{ .Name | title }} = mapItems
		}
	}
	{{- else if eq .Type "array" }}
	{{- if .Required }}
	resp.Diagnostics.Append(common.{{ if eq .GoType "types.Set" }}PopulateSetField{{ else }}PopulateSliceField{{ end }}(ctx, data.{{ .Name | title }}, &requestBody.{{ .Name | title }})...)
	{{- else }}
	resp.Diagnostics.Append(common.{{ if eq .GoType "types.Set" }}PopulateOptionalSetField{{ else }}PopulateOptionalSliceField{{ end }}(ctx, data.{{ .Name | title }}, &requestBody.{{ .Name | title }})...)
	{{- end }}
	{{- else if eq .Type "object" }}
	{{- if .Required }}
	{{- /* Required objects are just the struct, not a pointer to it usually? No, our SDK use pointers for objects too often. */ -}}
	var obj {{ if .RefName }}common.{{ .RefName }}{{ else }}{{ $.Prefix }}{{ .Name | title }}Request{{ end }}
	diags := data.{{ .Name | title }}.As(ctx, &obj, basetypes.ObjectAsOptions{})
	resp.Diagnostics.Append(diags...)
	if !diags.HasError() {
		requestBody.{{ .Name | title }} = obj
	}
	{{- else }}
	resp.Diagnostics.Append(common.PopulateOptionalObjectField(ctx, data.{{ .Name | title }}, &requestBody.{{ .Name | title }})...)
	{{- end }}
	{{- end }}
{{- end -}}


{{- /* Helper template for building COMPLEX request body fields (Post-Init) */ -}}
{{- define "buildComplexRequestBodyFields" -}}
{{- range .Fields }}
{{- if or (eq .Type "array") (eq .Type "object") (eq .GoType "types.Map") }}
{{- if $.Operation }}
{{- if not (isPathParam $.Operation .Name) }}
{{- template "complexFieldAssignment" dict "Name" .Name "Type" .Type "GoType" .GoType "ItemType" .ItemType "Required" .Required "Prefix" $.Prefix "Operation" $.Operation "ItemSchema" .ItemSchema "RefName" .RefName }}
{{- end }}
{{- else }}
{{- template "complexFieldAssignment" dict "Name" .Name "Type" .Type "GoType" .GoType "ItemType" .ItemType "Required" .Required "Prefix" $.Prefix "Operation" nil "ItemSchema" .ItemSchema "RefName" .RefName }}
{{- end }}
{{- end }}
{{- end }}
{{- end -}}

{{- /* Standard Create Operation */ -}}
{{- define "resource_create" }}
	{{- /* Check if there are any body fields (non-path-param fields) */ -}}
	{{- $hasCreate := or .APIPaths.Create .CreateOperation }}
	{{- if $hasCreate }}
	var data {{ .Name | title }}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() { return }

	requestBody := {{ .Name | title }}CreateRequest{}
	{{- range .CreateFields }}
	{{- if not (or (eq .Type "array") (eq .Type "object") (eq .GoType "types.Map")) }}
	{{- $isPath := false }}
	{{- if $.CreateOperation }}
		{{- if isPathParam $.CreateOperation .Name }}{{ $isPath = true }}{{ end }}
	{{- end }}
	{{- if not $isPath }}
	{{- /* Required fields are always sent, optional only if not null/unknown */ -}}
	{{- if .Required }}
	{{ template "fieldAssignment" dict "Field" . "Target" "requestBody" }}
	{{- else }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.IsUnknown() {
		{{ template "fieldAssignment" dict "Field" . "Target" "requestBody" }}
	}
	{{- end }}
	{{- end }}
	{{- end }}
	{{- end }}

	{{- if .CreateOperation }}
	{{- template "buildComplexRequestBodyFields" dict "Fields" .CreateFields "Operation" .CreateOperation "Prefix" (printf "%sCreate" (.Name | title)) }}
	{{- else }}
	{{- template "buildComplexRequestBodyFields" dict "Fields" .CreateFields "Operation" nil "Prefix" (printf "%sCreate" (.Name | title)) }}
	{{- end }}

	apiResp, err := r.client.Create(ctx, {{ if .CreateOperation }}{{ range $key, $value := .CreateOperation.PathParams }}data.{{ $value | title }}.ValueString(), {{ end }}{{ end }}&requestBody)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Create {{ .Name | humanize }}",
			"An error occurred while creating the {{ .Name | humanize }}: "+err.Error(),
		)
		return
	}

	{{- if .CompositeKeys }}
	// Build composite ID from key fields
	compositeID := ""
	{{- range $i, $key := .CompositeKeys }}
	{{- if $i }}
	compositeID += "/"
	{{- end }}
	if apiResp.{{ $key | title }} != nil {
		val := common.ExtractUUIDFromURL(*apiResp.{{ $key | title }})
		compositeID += val
	}
	{{- end }}
	data.UUID = types.StringValue(compositeID)
	{{- else }}
	data.UUID = types.StringPointerValue(apiResp.UUID)
	{{- end }}

	{{- if not .SkipPolling }}
	createTimeout, diags := data.Timeouts.Create(ctx, common.DefaultCreateTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	newResp, err := common.WaitForResource(ctx, func(ctx context.Context) (*{{ .Name | title }}Response, error) {
		return r.client.Get(ctx, data.UUID.ValueString())
	}, createTimeout)
	if err != nil {
		resp.Diagnostics.AddError("Failed to wait for resource creation", err.Error())
		return
	}
	apiResp = newResp
	{{- end }}

	resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	{{- else }}
	resp.Diagnostics.AddError("Creation Not Supported", "This resource cannot be created via the API.")
	{{- end }}
{{- end }}

{{- /* Standard Read Operation */ -}}
{{- define "resource_read" }}
	{{ template "resource_read_base" . }}
{{- end }}

{{- /* Standard Update Operation */ -}}
{{- define "resource_update" }}
	{{- if .APIPaths.Update }}
	var data {{ .Name | title }}ResourceModel
	var state {{ .Name | title }}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() { return }

	requestBody := {{ .Name | title }}UpdateRequest{}
	{{- range .UpdateFields }}
	{{- if not (or (eq .Type "array") (eq .Type "object") (eq .GoType "types.Map")) }}
	if !data.{{ .Name | title }}.IsNull() && !data.{{ .Name | title }}.IsUnknown() {
		{{ template "fieldAssignment" dict "Field" . "Target" "requestBody" }}
	}
	{{- end }}
	{{- end }}
	{{- template "buildComplexRequestBodyFields" dict "Fields" .UpdateFields "Operation" nil "Prefix" (printf "%sUpdate" (.Name | title)) }}

	apiResp, err := r.client.Update(ctx, data.UUID.ValueString(), &requestBody)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Update {{ .Name | humanize }}",
			"An error occurred while updating the {{ .Name | humanize }}: "+err.Error(),
		)
		return
	}

	{{- if not .SkipPolling }}
	updateTimeout, diags := data.Timeouts.Update(ctx, common.DefaultUpdateTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	newResp, err := common.WaitForResource(ctx, func(ctx context.Context) (*{{ .Name | title }}Response, error) {
		return r.client.Get(ctx, data.UUID.ValueString())
	}, updateTimeout)
	if err != nil {
		resp.Diagnostics.AddError("Failed to wait for resource update", err.Error())
		return
	}
	apiResp = newResp
	{{- end }}

	resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	{{- else }}
	resp.Diagnostics.AddError("Update Not Supported", "This resource cannot be updated via the API.")
	{{- end }}
{{- end }}

{{- /* Standard Delete Operation */ -}}
{{- define "resource_delete" }}
	{{- if .APIPaths.Delete }}
	var data {{ .Name | title }}ResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() { return }

	err := r.client.Delete(ctx, data.UUID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Delete {{ .Name | humanize }}",
			"An error occurred while deleting the {{ .Name | humanize }}: "+err.Error(),
		)
		return
	}

	{{- if not .SkipPolling }}
	deleteTimeout, diags := data.Timeouts.Delete(ctx, common.DefaultDeleteTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	err = common.WaitForDeletion(ctx, func(ctx context.Context) (*{{ .Name | title }}Response, error) {
		return r.client.Get(ctx, data.UUID.ValueString())
	}, deleteTimeout)
	if err != nil {
		resp.Diagnostics.AddError("Failed to wait for resource deletion", err.Error())
		return
	}
	{{- end }}
	{{- else }}
	resp.Diagnostics.AddError("Deletion Not Supported", "This resource cannot be deleted via the API.")
	{{- end }}
{{- end }}

{{- /* Standard Import Operation */ -}}
{{- define "resource_import" }}
	{{ template "resource_import_base" . }}
{{- end }}
