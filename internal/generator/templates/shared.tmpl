{{- /* Helper: Convert Terraform value to Go interface{} (for lists) */ -}}
{{- define "tfListToGo" -}}
{{- if eq .ItemType "string" }}
var items{{ .Suffix }} []interface{}
for _, elem := range data.{{ .FieldName }}.Elements() {
	if strVal, ok := elem.(types.String); ok {
		items{{ .Suffix }} = append(items{{ .Suffix }}, strVal.ValueString())
	}
}
{{- else if eq .ItemType "integer" }}
var items{{ .Suffix }} []interface{}
for _, elem := range data.{{ .FieldName }}.Elements() {
	if intVal, ok := elem.(types.Int64); ok {
		items{{ .Suffix }} = append(items{{ .Suffix }}, intVal.ValueInt64())
	}
}
{{- else if eq .ItemType "object" }}
var items{{ .Suffix }} []interface{}
for _, elem := range data.{{ .FieldName }}.Elements() {
	if objVal, ok := elem.(types.Object); ok {
		objMap := make(map[string]interface{})
		for key, attr := range objVal.Attributes() {
			switch v := attr.(type) {
			case types.String:
				objMap[key] = v.ValueString()
			case types.Int64:
				objMap[key] = v.ValueInt64()
			case types.Bool:
				objMap[key] = v.ValueBool()
			case types.Float64:
				objMap[key] = v.ValueFloat64()
			}
		}
		items{{ .Suffix }} = append(items{{ .Suffix }}, objMap)
	}
}
{{- end }}
{{- end -}}

{{- define "mapResponseFields" }}
	// Map response fields to data model
	_ = sourceMap
	{{- range .ModelFields }}
	{{- if ne .Name "name" }}
	if val, ok := sourceMap["{{ .Name }}"]; ok && val != nil {
		{{- if or (eq .Name "project") (eq .Name "offering") }}
		if str, ok := val.(string); ok {
			// Normalize URL to UUID
			parts := strings.Split(strings.TrimRight(str, "/"), "/")
			uuid := parts[len(parts)-1]
			data.{{ .Name | title }} = types.StringValue(uuid)
		} else {
			data.{{ .Name | title }} = types.StringNull()
		}
		{{- else if eq .Type "string" }}
		if str, ok := val.(string); ok {
			data.{{ .Name | title }} = types.StringValue(str)
		}
		{{- else if eq .Type "integer" }}
		if num, ok := val.(float64); ok {
			data.{{ .Name | title }} = types.Int64Value(int64(num))
		}
		{{- else if eq .Type "boolean" }}
		if b, ok := val.(bool); ok {
			data.{{ .Name | title }} = types.BoolValue(b)
		}
		{{- else if eq .Type "number" }}
		if num, ok := val.(float64); ok {
			data.{{ .Name | title }} = types.Float64Value(num)
		}
		{{- else if eq .Type "array" }}
		{{- if eq .ItemType "string" }}
		// List of strings (or flattened objects)
		if arr, ok := val.([]interface{}); ok {
			items := make([]attr.Value, 0, len(arr))
			for _, item := range arr {
				if str, ok := item.(string); ok {
					items = append(items, types.StringValue(str))
				} else if obj, ok := item.(map[string]interface{}); ok {
					// Flattening logic: extract URL or UUID
					if url, ok := obj["url"].(string); ok {
						parts := strings.Split(strings.TrimRight(url, "/"), "/")
						uuid := parts[len(parts)-1]
						items = append(items, types.StringValue(uuid))
					} else if uuid, ok := obj["uuid"].(string); ok {
						items = append(items, types.StringValue(uuid))
					} else if name, ok := obj["name"].(string); ok {
						items = append(items, types.StringValue(name))
					}
				}
			}
			listVal, _ := types.ListValue(types.StringType, items)
			data.{{ .Name | title }} = listVal
		}
		{{- else if eq .ItemType "object" }}
		// List of objects
		if arr, ok := val.([]interface{}); ok {
			items := make([]attr.Value, 0, len(arr))
			for _, item := range arr {
				if objMap, ok := item.(map[string]interface{}); ok {
					attrTypes := map[string]attr.Type{
						{{- range .ItemSchema.Properties }}
						"{{ .TFSDKName }}": {{ toAttrType . }},

						{{- end }}
					}
					attrValues := map[string]attr.Value{
						{{- range .ItemSchema.Properties }}
						{{- if eq .Type "string" }}
						"{{ .TFSDKName }}": func() attr.Value {
							if v, ok := objMap["{{ .Name }}"].(string); ok {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						{{- else if eq .Type "integer" }}
						"{{ .TFSDKName }}": func() attr.Value {
							if v, ok := objMap["{{ .Name }}"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						{{- else if eq .Type "boolean" }}
						"{{ .TFSDKName }}": func() attr.Value {
							if v, ok := objMap["{{ .Name }}"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						{{- else if eq .Type "number" }}
						"{{ .TFSDKName }}": func() attr.Value {
							if v, ok := objMap["{{ .Name }}"].(float64); ok {
								return types.Float64Value(v)
							}
							return types.Float64Null()
						}(),
						{{- else if eq .Type "object" }}
						"{{ .TFSDKName }}": types.ObjectNull({{ toAttrType . }}.AttrTypes),
						{{- else if eq .Type "array" }}
						"{{ .TFSDKName }}": types.ListNull({{ toAttrType . }}.ElemType),
						{{- else }}
						"{{ .TFSDKName }}": types.StringNull(),
						{{- end }}
						{{- end }}
					}
					objVal, _ := types.ObjectValue(attrTypes, attrValues)
					items = append(items, objVal)
				}
			}
			listVal, _ := types.ListValue(types.ObjectType{AttrTypes: map[string]attr.Type{
				{{- range .ItemSchema.Properties }}
				"{{ .TFSDKName }}": {{ toAttrType . }},
				{{- end }}
			}}, items)
			data.{{ .Name | title }} = listVal
		}
		{{- end }}
		{{- else if eq .Type "object" }}
		// Nested object
		if objMap, ok := val.(map[string]interface{}); ok {
			_ = objMap // Avoid unused variable if properties are empty
			attrTypes := map[string]attr.Type{
				{{- range .Properties }}
				"{{ .TFSDKName }}": {{ toAttrType . }},
				{{- end }}
			}
				attrValues := map[string]attr.Value{
					{{- range .Properties }}
					{{- if eq .Type "string" }}
					"{{ .TFSDKName }}": func() attr.Value {
						if v, ok := objMap["{{ .Name }}"].(string); ok {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					{{- else if eq .Type "integer" }}
					"{{ .TFSDKName }}": func() attr.Value {
						if v, ok := objMap["{{ .Name }}"].(float64); ok {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					{{- else if eq .Type "boolean" }}
					"{{ .TFSDKName }}": func() attr.Value {
						if v, ok := objMap["{{ .Name }}"].(bool); ok {
							return types.BoolValue(v)
						}
						return types.BoolNull()
					}(),
					{{- else if eq .Type "number" }}
					"{{ .TFSDKName }}": func() attr.Value {
						if v, ok := objMap["{{ .Name }}"].(float64); ok {
							return types.Float64Value(v)
						}
						return types.Float64Null()
					}(),
					{{- else if eq .Type "object" }}
					"{{ .TFSDKName }}": types.ObjectNull({{ toAttrType . }}.AttrTypes),
					{{- else if eq .Type "array" }}
					"{{ .TFSDKName }}": types.ListNull({{ toAttrType . }}.ElemType),
					{{- else }}
					"{{ .TFSDKName }}": types.StringNull(),
					{{- end }}
					{{- end }}
				}
			objVal, _ := types.ObjectValue(attrTypes, attrValues)
			data.{{ .Name | title }} = objVal
		}
		{{- end }}
	} else {
		if data.{{ .Name | title }}.IsUnknown() {
			{{- if eq .Type "string" }}
			data.{{ .Name | title }} = types.StringNull()
			{{- else if eq .Type "integer" }}
			data.{{ .Name | title }} = types.Int64Null()
			{{- else if eq .Type "boolean" }}
			data.{{ .Name | title }} = types.BoolNull()
			{{- else if eq .Type "number" }}
			data.{{ .Name | title }} = types.Float64Null()
			{{- else if eq .Type "array" }}
			{{- if eq .ItemType "string" }}
			data.{{ .Name | title }} = types.ListNull(types.StringType)
			{{- else if eq .ItemType "integer" }}
			data.{{ .Name | title }} = types.ListNull(types.Int64Type)
			{{- else if eq .ItemType "boolean" }}
			data.{{ .Name | title }} = types.ListNull(types.BoolType)
			{{- else if eq .ItemType "number" }}
			data.{{ .Name | title }} = types.ListNull(types.Float64Type)
			{{- else if eq .ItemType "object" }}
			data.{{ .Name | title }} = types.ListNull(types.ObjectType{AttrTypes: map[string]attr.Type{
				{{- range .ItemSchema.Properties }}
				"{{ .TFSDKName }}": {{ toAttrType . }},
				{{- end }}
			}})
			{{- end }}
			{{- else if eq .Type "object" }}
			data.{{ .Name | title }} = types.ObjectNull(map[string]attr.Type{
				{{- range .Properties }}
				"{{ .TFSDKName }}": {{ toAttrType . }},
				{{- end }}
			})
			{{- end }}
		}
	}
	{{- end }}
	{{- end }}

	// Map filter parameters from response if available
	{{- range .FilterParams }}
	if val, ok := sourceMap["{{ .Name }}"]; ok && val != nil {
		{{- if eq .Type "String" }}
		if str, ok := val.(string); ok {
			data.{{ .TFSDKName | title }} = types.StringValue(str)
		}
		{{- else if eq .Type "Int64" }}
		if num, ok := val.(float64); ok {
			data.{{ .TFSDKName | title }} = types.Int64Value(int64(num))
		}
		{{- else if eq .Type "Bool" }}
		if b, ok := val.(bool); ok {
			data.{{ .TFSDKName | title }} = types.BoolValue(b)
		}
		{{- else if eq .Type "Float64" }}
		if num, ok := val.(float64); ok {
			data.{{ .TFSDKName | title }} = types.Float64Value(num)
		}
		{{- end }}
	}
	{{- end }}
{{- end }}



{{- define "schemaNestedAttribute" }}
{{- if eq .GoType "types.List" }}
schema.ListNestedAttribute{
    NestedObject: schema.NestedAttributeObject{
        Attributes: map[string]schema.Attribute{
            {{- range .ItemSchema.Properties }}
                "{{ .TFSDKName }}": {{ template "schemaAttribute" . }}
            {{- end }}
        },
    },
    {{- if .ReadOnly }}
    Computed: true,
    {{- else if .Required }}
    Required: true,
    {{- else }}
    Optional: true,
    Computed: true,
    {{- end }}
    MarkdownDescription: "{{ or (.Description | sanitize) " " }}",
},
{{- else if eq .GoType "types.Object" }}
schema.SingleNestedAttribute{
    Attributes: map[string]schema.Attribute{
        {{- range .Properties }}
            "{{ .TFSDKName }}": {{ template "schemaAttribute" . }}
        {{- end }}
    },
    {{- if .ReadOnly }}
    Computed: true,
    {{- else if .Required }}
    Required: true,
    {{- else }}
    Optional: true,
    Computed: true,
    {{- end }}
    MarkdownDescription: "{{ or (.Description | sanitize) " " }}",
},
{{- end }}
{{- end }}

{{- define "schemaAttribute" }}
{{- if or (eq .GoType "types.List") (eq .GoType "types.Object") }}
    {{- if or (and (eq .GoType "types.List") (eq .ItemType "object")) (eq .GoType "types.Object") }}
        {{ template "schemaNestedAttribute" . }}
    {{- else }}
        {{- /* List of primitives */ -}}
        schema.ListAttribute{
            CustomType: {{ toAttrType . }},
            {{- if .ReadOnly }}
            Computed: true,
            {{- else if .Required }}
            Required: true,
            {{- else }}
            Optional: true,
            Computed: true,
            {{- end }}
            MarkdownDescription: "{{ or (.Description | sanitize) " " }}",
        },
    {{- end }}
{{- else }}
    {{- /* Primitive Type */ -}}
    schema.{{ if eq .Type "string" }}String{{ else if eq .Type "integer" }}Int64{{ else if eq .Type "boolean" }}Bool{{ else if eq .Type "number" }}Float64{{ end }}Attribute{
        {{- if .ReadOnly }}
        Computed: true,
        {{- else if .Required }}
        Required: true,
        {{- else }}
        Optional: true,
        Computed: true,
        {{- end }}
        {{- if or (eq .Name "project") (eq .Name "offering") }}
        PlanModifiers: []planmodifier.String{
            stringplanmodifier.RequiresReplace(),
        },
        {{- end }}
        MarkdownDescription: "{{ or (.Description | sanitize) " " }}",
        {{- if eq .Name "password" }}
        Sensitive: true,
        {{- end }}
    },
{{- end }}
{{- end }}
{{- define "mapPartialResponseFields" }}
	// Map partial response fields (only changed fields and state)
	_ = sourceMap

	// Always refresh State if present in model
	{{- range .ModelFields }}
	{{- if eq .Name "state" }}
	if val, ok := sourceMap["state"]; ok && val != nil {
		if str, ok := val.(string); ok {
			data.State = types.StringValue(str)
		}
	}
	{{- end }}
	{{- end }}

	{{- range .UpdateFields }}
	if !data.{{ .Name | title }}.IsNull() {
		if val, ok := sourceMap["{{ .Name }}"]; ok && val != nil {
			{{- if eq .Type "string" }}
			if str, ok := val.(string); ok {
				data.{{ .Name | title }} = types.StringValue(str)
			}
			{{- else if eq .Type "integer" }}
			if num, ok := val.(float64); ok {
				data.{{ .Name | title }} = types.Int64Value(int64(num))
			}
			{{- else if eq .Type "boolean" }}
			if b, ok := val.(bool); ok {
				data.{{ .Name | title }} = types.BoolValue(b)
			}
			{{- else if eq .Type "number" }}
			if num, ok := val.(float64); ok {
				data.{{ .Name | title }} = types.Float64Value(num)
			}
			{{- else if eq .Type "array" }}
			{{- if eq .ItemType "string" }}
			if arr, ok := val.([]interface{}); ok {
				items := make([]attr.Value, 0, len(arr))
				for _, item := range arr {
					if str, ok := item.(string); ok {
						items = append(items, types.StringValue(str))
					}
				}
				listVal, _ := types.ListValue(types.StringType, items)
				data.{{ .Name | title }} = listVal
			}
			{{- else if eq .ItemType "object" }}
			if arr, ok := val.([]interface{}); ok {
				items := make([]attr.Value, 0, len(arr))
				for _, item := range arr {
					if objMap, ok := item.(map[string]interface{}); ok {
						attrTypes := map[string]attr.Type{
							{{- range .ItemSchema.Properties }}
							"{{ .TFSDKName }}": {{ toAttrType . }},

							{{- end }}
						}
						attrValues := map[string]attr.Value{
							{{- range .ItemSchema.Properties }}
							{{- if eq .Type "string" }}
							"{{ .TFSDKName }}": func() attr.Value {
								if v, ok := objMap["{{ .Name }}"].(string); ok {
									return types.StringValue(v)
								}
								return types.StringNull()
							}(),
							{{- else if eq .Type "integer" }}
							"{{ .TFSDKName }}": func() attr.Value {
								if v, ok := objMap["{{ .Name }}"].(float64); ok {
									return types.Int64Value(int64(v))
								}
								return types.Int64Null()
							}(),
							{{- else if eq .Type "boolean" }}
							"{{ .TFSDKName }}": func() attr.Value {
								if v, ok := objMap["{{ .Name }}"].(bool); ok {
									return types.BoolValue(v)
								}
								return types.BoolNull()
							}(),
							{{- else if eq .Type "number" }}
							"{{ .TFSDKName }}": func() attr.Value {
								if v, ok := objMap["{{ .Name }}"].(float64); ok {
									return types.Float64Value(v)
								}
								return types.Float64Null()
							}(),
							{{- else if eq .Type "object" }}
							"{{ .TFSDKName }}": types.ObjectNull({{ toAttrType . }}.AttrTypes),
							{{- else if eq .Type "array" }}
							"{{ .TFSDKName }}": types.ListNull({{ toAttrType . }}.ElemType),
							{{- else }}
							"{{ .TFSDKName }}": types.StringNull(),
							{{- end }}
							{{- end }}
						}
						objVal, _ := types.ObjectValue(attrTypes, attrValues)
						items = append(items, objVal)
					}
				}
				listVal, _ := types.ListValue(types.ObjectType{AttrTypes: map[string]attr.Type{
					{{- range .ItemSchema.Properties }}
					"{{ .TFSDKName }}": {{ toAttrType . }},
					{{- end }}
				}}, items)
				data.{{ .Name | title }} = listVal
			}
			{{- end }}
			{{- else if eq .Type "object" }}
			if objMap, ok := val.(map[string]interface{}); ok {
				_ = objMap
				attrTypes := map[string]attr.Type{
					{{- range .Properties }}
					"{{ .TFSDKName }}": {{ toAttrType . }},
					{{- end }}
				}
				attrValues := map[string]attr.Value{
					{{- range .Properties }}
					{{- if eq .Type "string" }}
					"{{ .TFSDKName }}": func() attr.Value {
						if v, ok := objMap["{{ .Name }}"].(string); ok {
							return types.StringValue(v)
						}
						return types.StringNull()
					}(),
					{{- else if eq .Type "integer" }}
					"{{ .TFSDKName }}": func() attr.Value {
						if v, ok := objMap["{{ .Name }}"].(float64); ok {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					{{- else if eq .Type "boolean" }}
					"{{ .TFSDKName }}": func() attr.Value {
						if v, ok := objMap["{{ .Name }}"].(bool); ok {
							return types.BoolValue(v)
						}
						return types.BoolNull()
					}(),
					{{- else if eq .Type "number" }}
					"{{ .TFSDKName }}": func() attr.Value {
						if v, ok := objMap["{{ .Name }}"].(float64); ok {
							return types.Float64Value(v)
						}
						return types.Float64Null()
					}(),
					{{- else if eq .Type "object" }}
					"{{ .TFSDKName }}": types.ObjectNull({{ toAttrType . }}.AttrTypes),
					{{- else if eq .Type "array" }}
					"{{ .TFSDKName }}": types.ListNull({{ toAttrType . }}.ElemType),
					{{- else }}
					"{{ .TFSDKName }}": types.StringNull(),
					{{- end }}
					{{- end }}
				}
				objVal, _ := types.ObjectValue(attrTypes, attrValues)
				data.{{ .Name | title }} = objVal
			}
			{{- end }}
		}
	}
	{{- end }}
{{- end }}

{{- define "convertTFValue" }}
{{ if .HasComplexTypes }}
func (r *{{ .Name | title }}Resource) convertTFValue(v attr.Value) interface{} {
	if v.IsNull() || v.IsUnknown() {
		return nil
	}
	switch val := v.(type) {
	case types.String:
		return val.ValueString()
	case types.Int64:
		return val.ValueInt64()
	case types.Bool:
		return val.ValueBool()
	case types.Float64:
		return val.ValueFloat64()
	case types.List:
		items := make([]interface{}, len(val.Elements()))
		for i, elem := range val.Elements() {
			items[i] = r.convertTFValue(elem)
		}
		return items
	case types.Object:
		obj := make(map[string]interface{})
		for k, attr := range val.Attributes() {
			if converted := r.convertTFValue(attr); converted != nil {
				obj[k] = converted
			}
		}
		return obj
	}
	return nil
}
{{ end }}
{{- end }}
