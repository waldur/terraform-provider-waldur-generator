{{- /* Helper: Generate Request Struct Fields */ -}}
{{- define "apiRequestStructFields" }}
	{{- $prefix := .Prefix }}
	{{- $pkgName := .Package }}
	{{- range .Fields }}
	{{- /* Generate field with pointer types for optionality and json/tfsdk tags */ -}}
	{{ .Name | title }} {{ renderGoType . $pkgName $prefix "" }} `json:"{{ if .JsonTag }}{{ .JsonTag }}{{ else }}{{ .Name }}{{ if not .Required }},omitempty{{ end }}{{ end }}" tfsdk:"{{ .Name }}"`
	{{ end }}
{{- end }}

{{- /* Helper: Generate Nested Request Structs */ -}}
{{- define "apiRequestNestedStructs" }}
{{- $prefix := .Prefix }}
{{- $pkgName := .Package }}
{{- range .Fields }}
{{- if eq .Type "object" }}
{{- if not .RefName }}
{{- /* Recursively generate struct for nested object */ -}}
type {{ $prefix }}{{ .Name | title }} struct {
	{{ template "apiRequestStructFields" dict "Fields" .Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
}
{{ template "apiRequestNestedStructs" dict "Fields" .Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
{{- end }}
{{- else if and (eq .Type "array") (eq .ItemType "object") }}
{{- if not .ItemSchema.RefName }}
{{- /* Recursively generate struct for array of objects */ -}}
type {{ $prefix }}{{ .Name | title }} struct {
	{{ template "apiRequestStructFields" dict "Fields" .ItemSchema.Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
}
{{ template "apiRequestNestedStructs" dict "Fields" .ItemSchema.Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
{{- end }}
{{- end }}
{{- end }}
{{- end }}


{{- /* Helper: Map Response Struct to Terraform Model */ -}}
{{- define "mapResponseToModel" }}
	{{- $prefix := .Name | title }}
	{{- $fields := .ResponseFields }}
	{{- range $fields }}
	{{- if not .SchemaSkip }}
	{{- /* Handle basic types */ -}}
	{{- if eq .Type "string" }}
	{{- if eq .Format "date-time" }}
	val{{ .Name | title }}, diags{{ .Name | title }} := timetypes.NewRFC3339PointerValue(apiResp.{{ .Name | title }})
	diags.Append(diags{{ .Name | title }}...)
	model.{{ .Name | title }} = val{{ .Name | title }}
	{{- else }}
	model.{{ .Name | title }} = common.StringPointerValue(apiResp.{{ .Name | title }})
	{{- end }}
	{{- else if eq .Type "integer" }}
	model.{{ .Name | title }} = types.Int64PointerValue(apiResp.{{ .Name | title }})
	{{- else if eq .Type "boolean" }}
	model.{{ .Name | title }} = types.BoolPointerValue(apiResp.{{ .Name | title }})
	{{- else if eq .Type "number" }}
	model.{{ .Name | title }} = types.Float64PointerValue(apiResp.{{ .Name | title }}.Float64Ptr())
	{{- else if eq .Type "array" }}
	{{- if eq .GoType "types.Set" }}
	{{- if eq .ItemType "string" }}
	setVal{{ .Name | title }}, setDiags{{ .Name | title }} := types.SetValueFrom(ctx, types.StringType, apiResp.{{ .Name | title }})
	model.{{ .Name | title }} = setVal{{ .Name | title }}
	diags.Append(setDiags{{ .Name | title }}...)
	{{- else if eq .ItemType "object" }}
	if apiResp.{{ .Name | title }} != nil && len(*apiResp.{{ .Name | title }}) > 0 {
		setVal{{ .Name | title }}, setDiags{{ .Name | title }} := types.SetValueFrom(ctx, {{ toAttrType .ItemSchema }}, apiResp.{{ .Name | title }})
		diags.Append(setDiags{{ .Name | title }}...)
		model.{{ .Name | title }} = setVal{{ .Name | title }}
	} else {
		model.{{ .Name | title }} = types.SetNull({{ toAttrType .ItemSchema }})
	}
	{{- end }}
	{{- else }}
	{{- /* Default to List */ -}}
	{{- if eq .ItemType "string" }}
	listVal{{ .Name | title }}, listDiags{{ .Name | title }} := types.ListValueFrom(ctx, types.StringType, apiResp.{{ .Name | title }})
	model.{{ .Name | title }} = listVal{{ .Name | title }}
	diags.Append(listDiags{{ .Name | title }}...)
	{{- else if eq .ItemType "object" }}
	{{/* For list of objects, convert each item to Terraform object */}}
	{{- if .Required }}
	if len(apiResp.{{ .Name | title }}) > 0 {
		listVal{{ .Name | title }}, listDiags{{ .Name | title }} := types.ListValueFrom(ctx, {{ toAttrType .ItemSchema }}, apiResp.{{ .Name | title }})
		diags.Append(listDiags{{ .Name | title }}...)
		model.{{ .Name | title }} = listVal{{ .Name | title }}
	} else {
		model.{{ .Name | title }} = types.ListNull({{ toAttrType .ItemSchema }})
	}
	{{- else }}
	if apiResp.{{ .Name | title }} != nil && len(*apiResp.{{ .Name | title }}) > 0 {
		listVal{{ .Name | title }}, listDiags{{ .Name | title }} := types.ListValueFrom(ctx, {{ toAttrType .ItemSchema }}, apiResp.{{ .Name | title }})
		diags.Append(listDiags{{ .Name | title }}...)
		model.{{ .Name | title }} = listVal{{ .Name | title }}
	} else {
		model.{{ .Name | title }} = types.ListNull({{ toAttrType .ItemSchema }})
	}
	{{- end }}
	{{- end }}
	{{- end }}
	{{- else if eq .GoType "types.Set" }}
	{{- if eq .ItemType "string" }}
	setVal{{ .Name | title }}, setDiags{{ .Name | title }} := types.SetValueFrom(ctx, types.StringType, apiResp.{{ .Name | title }})
	model.{{ .Name | title }} = setVal{{ .Name | title }}
	diags.Append(setDiags{{ .Name | title }}...)
	{{- else if eq .ItemType "object" }}
	if apiResp.{{ .Name | title }} != nil && len(*apiResp.{{ .Name | title }}) > 0 {
		setVal{{ .Name | title }}, setDiags{{ .Name | title }} := types.SetValueFrom(ctx, {{ toAttrType .ItemSchema }}, apiResp.{{ .Name | title }})
		diags.Append(setDiags{{ .Name | title }}...)
		model.{{ .Name | title }} = setVal{{ .Name | title }}
	} else {
		model.{{ .Name | title }} = types.SetNull({{ toAttrType .ItemSchema }})
	}
	{{- end }}
	{{- else if eq .GoType "types.Map" }}
	if apiResp.{{ .Name | title }} != nil {
		mapVal{{ .Name | title }}, mapDiags{{ .Name | title }} := types.MapValueFrom(ctx, types.StringType, apiResp.{{ .Name | title }})
		diags.Append(mapDiags{{ .Name | title }}...)
		model.{{ .Name | title }} = mapVal{{ .Name | title }}
	} else {
		model.{{ .Name | title }} = types.MapNull(types.StringType)
	}
	{{- else if eq .Type "object" }}
	if apiResp.{{ .Name | title }} != nil {
		objVal{{ .Name | title }}, objDiags{{ .Name | title }} := types.ObjectValueFrom(ctx, {{ toAttrType . }}.AttrTypes, *apiResp.{{ .Name | title }})
		diags.Append(objDiags{{ .Name | title }}...)
		model.{{ .Name | title }} = objVal{{ .Name | title }}
	} else {
		model.{{ .Name | title }} = types.ObjectNull({{ toAttrType . }}.AttrTypes)
	}
	{{- end }}
	{{- end }}
	{{- end }}
{{- end }}




{{- define "schemaNestedAttribute" }}
{{- if eq .GoType "types.List" }}
schema.ListNestedAttribute{
    NestedObject: schema.NestedAttributeObject{
        Attributes: map[string]schema.Attribute{
            {{- range .ItemSchema.Properties }}
                "{{ .Name }}": {{ template "schemaAttribute" . }}
            {{- end }}
        },
    },
    {{- if .ReadOnly }}
    Computed: true,
    {{- else if .Required }}
    Required: true,
    {{- else }}
    Optional: true,
    {{- if or .ServerComputed .ReadOnly }}
    Computed: true,
    {{- end }}
    {{- end }}
    {{- if not .IsDataSource }}
    {{- if or .ForceNew .ServerComputed .ReadOnly }}
    PlanModifiers: []planmodifier.List{
        {{- if .ForceNew }}
        listplanmodifier.RequiresReplace(),
        {{- end }}
        {{- if .UseStateForUnknown }}
        listplanmodifier.UseStateForUnknown(),
        {{- end }}
    },
    {{- end }}
    {{- end }}
    MarkdownDescription: "{{ or .Description " " }}",
},
{{- else if eq .GoType "types.Set" }}
schema.SetNestedAttribute{
    NestedObject: schema.NestedAttributeObject{
        Attributes: map[string]schema.Attribute{
            {{- range .ItemSchema.Properties }}
                "{{ .Name }}": {{ template "schemaAttribute" . }}
            {{- end }}
        },
    },
    {{- if .ReadOnly }}
    Computed: true,
    {{- else if .Required }}
    Required: true,
    {{- else }}
    Optional: true,
    {{- if or .ServerComputed .ReadOnly }}
    Computed: true,
    {{- end }}
    {{- end }}
    {{- if not .IsDataSource }}
    {{- if or .ForceNew .ServerComputed .ReadOnly }}
    PlanModifiers: []planmodifier.Set{
        {{- if .ForceNew }}
        // Set plan modifiers would go here if needed, but not standard in v1 yet for Sets in same way? 
        // Actually setplanmodifier exists
        setplanmodifier.RequiresReplace(),
        {{- end }}
        {{- if .UseStateForUnknown }}
        setplanmodifier.UseStateForUnknown(),
        {{- end }}
    },
    {{- end }}
    {{- end }}
    MarkdownDescription: "{{ or .Description " " }}",
},
{{- else if eq .GoType "types.Object" }}
schema.SingleNestedAttribute{
    Attributes: map[string]schema.Attribute{
        {{- range .Properties }}
            "{{ .Name }}": {{ template "schemaAttribute" . }}
        {{- end }}
    },
    {{- if .ReadOnly }}
    Computed: true,
    {{- else if .Required }}
    Required: true,
    {{- else }}
    Optional: true,
    {{- if or .ServerComputed .ReadOnly }}
    Computed: true,
    {{- end }}
    {{- end }}
    {{- if not .IsDataSource }}
    {{- if or .ForceNew .ServerComputed .ReadOnly }}
    PlanModifiers: []planmodifier.Object{
        {{- if .ForceNew }}
        objectplanmodifier.RequiresReplace(),
        {{- end }}
        {{- if .UseStateForUnknown }}
        objectplanmodifier.UseStateForUnknown(),
        {{- end }}
    },
    {{- end }}
    {{- end }}
    MarkdownDescription: "{{ or .Description " " }}",
},
{{- end }}
{{- end }}

{{- define "schemaAttribute" }}
{{- if or (eq .GoType "types.List") (eq .GoType "types.Object") (eq .GoType "types.Set") }}
    {{- if or (and (or (eq .GoType "types.List") (eq .GoType "types.Set")) (eq .ItemType "object")) (eq .GoType "types.Object") }}
        {{ template "schemaNestedAttribute" . }}
    {{- else }}
        {{- /* List/Set of primitives */ -}}
        schema.{{ if eq .GoType "types.List" }}List{{ else }}Set{{ end }}Attribute{
            ElementType: {{ if eq .ItemType "integer" }}types.Int64Type{{ else if eq .ItemType "boolean" }}types.BoolType{{ else if eq .ItemType "number" }}types.Float64Type{{ else }}types.StringType{{ end }},
            {{- if .ReadOnly }}
            Computed: true,
            {{- else if .Required }}
            Required: true,
            {{- else }}
            Optional: true,
            {{- if or .ServerComputed .ReadOnly }}
            Computed: true,
            {{- end }}
            {{- end }}
            {{- if not .IsDataSource }}
            {{- if or .ForceNew .ServerComputed .ReadOnly }}
            PlanModifiers: []planmodifier.{{ if eq .GoType "types.List" }}List{{ else }}Set{{ end }}{
                {{- if .ForceNew }}
                {{ if eq .GoType "types.List" }}listplanmodifier{{ else }}setplanmodifier{{ end }}.RequiresReplace(),
                {{- end }}
                {{- if .UseStateForUnknown }}
                {{ if eq .GoType "types.List" }}listplanmodifier{{ else }}setplanmodifier{{ end }}.UseStateForUnknown(),
                {{- end }}
            },
            {{- end }}
            {{- end }}
            MarkdownDescription: "{{ or .Description " " }}",
        },
    {{- end }}
{{- else if eq .GoType "types.Map" }}
    schema.MapAttribute{
        ElementType: {{ if eq .ItemType "integer" }}types.Int64Type{{ else if eq .ItemType "boolean" }}types.BoolType{{ else if eq .ItemType "number" }}types.Float64Type{{ else }}types.StringType{{ end }},
        {{- if .ReadOnly }}
        Computed: true,
        {{- else if .Required }}
        Required: true,
        {{- else }}
        Optional: true,
        {{- if or .ServerComputed .ReadOnly }}
        Computed: true,
        {{- end }}
        {{- end }}
        {{- if not .IsDataSource }}
        {{- if or .ForceNew .ServerComputed .ReadOnly }}
        PlanModifiers: []planmodifier.Map{
            {{- if .ForceNew }}
            mapplanmodifier.RequiresReplace(),
            {{- end }}
            {{- if .UseStateForUnknown }}
            mapplanmodifier.UseStateForUnknown(),
            {{- end }}
        },
        {{- end }}
        {{- end }}
        MarkdownDescription: "{{ or .Description " " }}",
    },
{{- else }}
    {{- /* Primitive Type */ -}}
    schema.{{ if eq .Type "string" }}String{{ else if eq .Type "integer" }}Int64{{ else if eq .Type "boolean" }}Bool{{ else if eq .Type "number" }}Float64{{ end }}Attribute{
        {{- if and (eq .Type "string") (eq .Format "date-time") }}
        CustomType: timetypes.RFC3339Type{},
        {{- end }}
        {{- if .ReadOnly }}
        Computed: true,
        {{- else if .Required }}
        Required: true,
        {{- else }}
        Optional: true,
        {{- if or .ServerComputed .ReadOnly }}
        Computed: true,
        {{- end }}
        {{- end }}
        {{- if not .IsDataSource }}
        {{- if or .ForceNew .ServerComputed .ReadOnly }}
        PlanModifiers: []planmodifier.{{ if eq .Type "string" }}String{{ else if eq .Type "integer" }}Int64{{ else if eq .Type "boolean" }}Bool{{ else if eq .Type "number" }}Float64{{ end }}{
            {{- if .ForceNew }}
            {{ if eq .Type "string" }}stringplanmodifier{{ else if eq .Type "integer" }}int64planmodifier{{ else if eq .Type "boolean" }}boolplanmodifier{{ else if eq .Type "number" }}float64planmodifier{{ end }}.RequiresReplace(),
            {{- end }}
            {{- if .UseStateForUnknown }}
            {{ if eq .Type "string" }}stringplanmodifier{{ else if eq .Type "integer" }}int64planmodifier{{ else if eq .Type "boolean" }}boolplanmodifier{{ else if eq .Type "number" }}float64planmodifier{{ end }}.UseStateForUnknown(),
            {{- end }}
        },
        {{- end }}
        {{- end }}
        MarkdownDescription: "{{ or .Description " " }}",
        {{- if contains .Name "password" }}
        Sensitive: true,
        {{- end }}
        {{- if or .Enum .Minimum .Maximum .Pattern }}
        Validators: []validator.{{ if eq .Type "string" }}String{{ else if eq .Type "integer" }}Int64{{ else if eq .Type "number" }}Float64{{ end }}{
            {{- if .Enum }}
            stringvalidator.OneOf({{ range $i, $e := .Enum }}{{ if $i }}, {{ end }}"{{ $e }}"{{ end }}),
            {{- end }}
            {{- if .Pattern }}
            stringvalidator.RegexMatches(regexp.MustCompile(`{{ .Pattern }}`), ""),
            {{- end }}
            {{- if .Minimum }}
            {{- $min := formatValidator .Minimum .GoType }}
            {{- if $min }}
            {{ if eq .Type "integer" }}int64validator{{ else }}float64validator{{ end }}.AtLeast({{ $min }}),
            {{- end }}
            {{- end }}
            {{- if .Maximum }}
            {{- $max := formatValidator .Maximum .GoType }}
            {{- if $max }}
            {{ if eq .Type "integer" }}int64validator{{ else }}float64validator{{ end }}.AtMost({{ $max }}),
            {{- end }}
            {{- end }}
        },
        {{- end }}
    },
{{- end }}
{{- end }}



{{- /* SDK Helper: Generate Request Struct Fields */ -}}
{{- define "sdkStructFields" }}
	{{- $prefix := .Prefix }}
	{{- $pkgName := .Package }}
	{{- range .Fields }}
	{{- if not .IsPathParam }}
	{{ .Name | title }} {{ renderGoType . $pkgName $prefix "Request" }} `json:"{{ if .JsonTag }}{{ .JsonTag }}{{ else }}{{ .Name }}{{ if not .Required }},omitempty{{ end }}{{ end }}" tfsdk:"{{ .Name }}"`
	{{- end }}
	{{- end }}
{{- end }}

{{- /* SDK Helper: Generate Nested Request Structs */ -}}
{{- define "sdkNestedStructs" }}
{{- $prefix := .Prefix }}
{{- $pkgName := .Package }}
{{- range .Fields }}
{{- if eq .Type "object" }}
{{- if not .RefName }}
type {{ $prefix }}{{ .Name | title }}Request struct {
	{{ template "sdkStructFields" dict "Fields" .Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
}
{{ template "sdkNestedStructs" dict "Fields" .Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
{{- end }}
{{- else if and (eq .Type "array") (eq .ItemType "object") }}
{{- if not .ItemSchema.RefName }}
type {{ $prefix }}{{ .Name | title }}Request struct {
	{{ template "sdkStructFields" dict "Fields" .ItemSchema.Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
}
{{ template "sdkNestedStructs" dict "Fields" .ItemSchema.Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
{{- end }}
{{- end }}
{{- end }}
{{- end }}

{{- /* SDK Helper: Generate Attributes Struct Fields (Filtering) */ -}}
{{- define "sdkAttributesStructFields" }}
	{{- $prefix := .Prefix }}
	{{- $pkgName := .Package }}
	{{- range .Fields }}
	{{- if and (ne .Name "project") (ne .Name "offering") }}
	{{ .Name | title }} {{ renderGoType . $pkgName $prefix "Request" }} `json:"{{ .Name }}{{ if not .Required }},omitempty{{ end }}"`
	{{- end }}
	{{- end }}
{{- end }}

{{- /* SDK Helper: Generate Response Struct Fields */ -}}
{{- define "sdkResponseStructFields" }}
	{{- $prefix := .Prefix }}
	{{- $pkgName := .Package }}
	{{- range .Fields }}
	{{ .Name | title }} {{ renderGoType . $pkgName $prefix "Response" }} `json:"{{ .Name }}" tfsdk:"{{ .Name }}"`
	{{- end }}
{{- end }}

{{- /* SDK Helper: Generate Nested Response Structs */ -}}
{{- define "sdkResponseNestedStructs" }}
{{- $prefix := .Prefix }}
{{- $pkgName := .Package }}
{{- range .Fields }}
{{- if eq .Type "object" }}
type {{ $prefix }}{{ .Name | title }}Response struct {
	{{ template "sdkResponseStructFields" dict "Fields" .Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
}
{{ template "sdkResponseNestedStructs" dict "Fields" .Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
{{- else if and (eq .Type "array") (eq .ItemType "object") }}
type {{ $prefix }}{{ .Name | title }}Response struct {
	{{ template "sdkResponseStructFields" dict "Fields" .ItemSchema.Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
}
{{ template "sdkResponseNestedStructs" dict "Fields" .ItemSchema.Properties "Prefix" (printf "%s%s" $prefix (.Name | title)) "Package" $pkgName }}
{{- end }}
{{- end }}
{{- end }}

{{- /* Helper: Assign simple field from Terraform data to a target variable */ -}}
{{- define "fieldAssignment" }}
{{ .Target }}.{{ .Field.Name | title }} = data.{{ .Field.Name | title }}.Value{{ if or (eq .Field.Type "string") (eq .Field.GoType "types.String") }}String{{ else if or (eq .Field.Type "integer") (eq .Field.GoType "types.Int64") }}Int64{{ else if or (eq .Field.Type "boolean") (eq .Field.GoType "types.Bool") }}Bool{{ else if or (eq .Field.Type "number") (eq .Field.GoType "types.Float64") }}Float64{{ end }}Pointer()
{{- end }}

{{- /* Shared Read Logic (Base) */ -}}
{{- define "resource_read_base" }}
	{{- if .CompositeKeys }}
	// If UUID is unknown or contains slashes (composite key), try to look it up using composite keys
	if data.UUID.IsNull() || data.UUID.IsUnknown() || strings.Contains(data.UUID.ValueString(), "/") {
		filters := map[string]string{}
		{{- range $key := .CompositeKeys }}
		if !data.{{ $key | title }}.IsNull() {
			if v := data.{{ $key | title }}.ValueString(); v != "" {
				filters["{{ $key }}"] = v
			}
		}
		{{- end }}

		expectedCount := 0
		{{- range .CompositeKeys }}
		expectedCount++
		{{- end }}

		if len(filters) == expectedCount {
			listResult, err := r.client.List(ctx, filters)
			if err != nil {
				resp.Diagnostics.AddError("Failed to lookup resource by composite keys", err.Error())
				return
			}
			
			if len(listResult) == 1 {
				data.UUID = types.StringPointerValue(listResult[0].UUID)
			} else if len(listResult) > 1 {
				resp.Diagnostics.AddError("Ambiguous resource", fmt.Sprintf("Found %d resources matching composite keys", len(listResult)))
				return
			} else {
				resp.Diagnostics.AddError("Resource not found", "No resource found matching composite keys")
				return
			}
		}
	}
	{{- end }}

	apiResp, err := r.client.Get(ctx, data.UUID.ValueString())
	if err != nil {
		if IsNotFoundError(err) {
			resp.State.RemoveResource(ctx)
			return
		}

		resp.Diagnostics.AddError(
			"Unable to Read {{ .Name | humanize }}",
			"An error occurred while reading the {{ .Name | humanize }}: "+err.Error(),
		)
		return
	}
	
	resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)
{{- end }}

{{- /* Shared Import Logic (Base) */ -}}
{{- define "resource_import_base" }}
	{{- if .CompositeKeys }}
	// Parse composite ID: key1/key2/...
	parts := strings.Split(req.ID, "/")
	if len(parts) != {{ len .CompositeKeys }} {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			"Expected format: {{ range $i, $key := .CompositeKeys }}{{ if $i }}/{{ end }}<{{ $key }}>{{ end }}",
		)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
	{{- range $i, $key := .CompositeKeys }}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("{{ $key }}"), parts[{{ $i }}])...)
	{{- end }}
	{{- else }}
	uuid := req.ID
	if uuid == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			"Import ID cannot be empty. Please provide the UUID of the {{ .Name | humanize }}.",
		)
		return
	}

	tflog.Info(ctx, "Importing {{ .Name | humanize }}", map[string]interface{}{
		"uuid": uuid,
	})

	apiResp, err := r.client.Get(ctx, uuid)
	if err != nil {
		if IsNotFoundError(err) {
			resp.Diagnostics.AddError(
				"Resource Not Found",
				fmt.Sprintf("{{ .Name | humanize }} with UUID '%s' does not exist or is not accessible.", uuid),
			)
			return
		}
		resp.Diagnostics.AddError(
			"Unable to Import {{ .Name | humanize }}",
			fmt.Sprintf("An error occurred while fetching the {{ .Name | humanize }}: %s", err.Error()),
		)
		return
	}

	var data {{ .Name | title }}ResourceModel
	resp.Diagnostics.Append(data.CopyFrom(ctx, *apiResp)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	{{- end }}
{{- end }}

